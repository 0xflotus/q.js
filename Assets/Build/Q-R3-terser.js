const Q=function(programText){`\n\tHi. Do you need help with something? \n\tEach Q class has its own description. \n\tFor example, try this:  \n\n\tQ.Qubit.help()\n\t`;return Q.Program.fromText(programText)};Object.assign(Q,{verbosity:.5,animals:[],colors:[],warn:function(){console.warn(...arguments);return"(warning)"},error:function(){console.error(...arguments);return"(error)"},extractDocumentation:function(f){`\n\t\tI wanted a way to document code\n\t\tthat was cleaner, more legible, and more elegant\n\t\tthan the bullshit we put up with today.\n\t\tAlso wanted it to print nicely in the console.\n\t\t`;f=f.toString();const begin=f.indexOf("`")+1,end=f.indexOf("`",begin),lines=f.substring(begin,end).split("\n");function countPrefixTabs(text){`\n\t\t\tIs counting tabs “manually” is actually more performant than regex?\n\t\t\t`;let count=index=0;while(text.charAt(index++)==="\t")count++;return count}let tabs=Number.MAX_SAFE_INTEGER;lines.forEach(function(line){if(line){const lineTabs=countPrefixTabs(line);if(tabs>lineTabs)tabs=lineTabs}});lines.forEach(function(line,i){if(line.trim()==="")line="\n\n";lines[i]=line.substring(tabs).replace(/ {2}$/,"\n")});return lines.join("")},help:function(f){if(f===undefined)f=Q;return Q.extractDocumentation(f)},constants:{},createConstant:function(key,value){this[key]=value;this.constants[key]=this[key];Object.freeze(this[key])},createConstants:function(){if(arguments.length%2!==0){return Q.error("Q attempted to create constants with invalid (KEY, VALUE) pairs.")}for(let i=0;i<arguments.length;i+=2){this.createConstant(arguments[i],arguments[i+1])}},loop:function(){},hypotenuse:function(x,y){let a=Math.abs(x),b=Math.abs(y);if(a<2048&&b<2048){return Math.sqrt(a*a+b*b)}if(a<b){a=b;b=x/y}else b=y/x;return a*Math.sqrt(1+b*b)},logHypotenuse:function(x,y){const a=Math.abs(x),b=Math.abs(y);if(x===0)return Math.log(b);if(y===0)return Math.log(a);if(a<2048&&b<2048){return Math.log(x*x+y*y)/2}return Math.log(x/Math.cos(Math.atan2(y,x)))},hyperbolicSine:function(n){return(Math.exp(n)-Math.exp(-n))/2},hyperbolicCosine:function(n){return(Math.exp(n)+Math.exp(-n))/2},round:function(n,d){if(typeof d!=="number")d=0;const f=Math.pow(10,d);return Math.round(n*f)/f},toTitleCase(text){text=text.replace(/_/g," ");return text.toLowerCase().split(" ").map(function(word){return word.replace(word[0],word[0].toUpperCase())}).join(" ")}});Q.createConstants("REVISION",3,"EPSILON",Number.EPSILON*6,"RADIANS_TO_DEGREES",180/Math.PI);Q.ComplexNumber=function(real,imaginary){`\n\tThe set of “real numbers” (ℝ) contains any number that can be expressed \n\talong an infinite timeline. https://en.wikipedia.org/wiki/Real_number  \n\n\t  …  -3  -2  -1   0  +1  +2  +3   …  \n\t  ┄───┴───┴───┴───┴───┴─┬─┴──┬┴┬──┄  \n\t                       √2    𝒆 π  \n\n\n\tMeanwhile, “imaginary numbers” (𝕀) consist of a real (ℝ) multiplier and \n\tthe symbol 𝒊, which is the impossible solution to the equation 𝒙² = −1. \n\tNote that no number when multiplied by itself can ever result in a \n\tnegative product, but the concept of 𝒊 gives us a way to reason around \n\tthis imaginary scenario nonetheless. \n\thttps://en.wikipedia.org/wiki/Imaginary_number  \n\n\t  …  -3𝒊 -2𝒊  -1𝒊  0𝒊  +1𝒊 +2𝒊 +3𝒊  …  \n\t  ┄───┴───┴───┴───┴───┴───┴───┴───┄  \n\n\n\tA “complex number“ (ℂ) is a number that can be expressed in the form \n\t𝒂 + 𝒃𝒊, where 𝒂 is the real component (ℝ) and 𝒃𝒊 is the imaginary \n\tcomponent (𝕀). https://en.wikipedia.org/wiki/Complex_number  \n\n\n\tOperation functions on Q.ComplexNumber instances generally accept as \n\targuments both sibling instances and pure Number instances, though the \n\tvalue returned is always an instance of Q.ComplexNumber.\n\n\t`;if(real instanceof Q.ComplexNumber){imaginary=real.imaginary;real=real.real;Q.warn("Q.ComplexNumber tried to create a new instance with an argument that is already a Q.ComplexNumber — and that’s weird!")}else if(real===undefined)real=0;if(imaginary===undefined)imaginary=0;if(Q.ComplexNumber.isNumberLike(real)!==true||Q.ComplexNumber.isNumberLike(imaginary)!==true)return Q.error("Q.ComplexNumber attempted to create a new instance but the arguments provided were not actual numbers.");this.real=real;this.imaginary=imaginary;this.index=Q.ComplexNumber.index++};Object.assign(Q.ComplexNumber,{index:0,help:function(){return Q.help(this)},constants:{},createConstant:Q.createConstant,createConstants:Q.createConstants,isNumberLike:function(n){return typeof n==="number"||n instanceof Number},isNaN:function(n){return isNaN(n.real)||isNaN(n.imaginary)},isZero:function(n){return(n.real===0||n.real===-0)&&(n.imaginary===0||n.imaginary===-0)},isFinite:function(n){return isFinite(n.real)&&isFinite(n.imaginary)},isInfinite:function(n){return!(this.isNaN(n)||this.isFinite(n))},areEqual:function(a,b){return Q.ComplexNumber.operate("areEqual",a,b,function(a,b){return Math.abs(a-b)<Q.EPSILON},function(a,b){return Math.abs(a-b.real)<Q.EPSILON&&Math.abs(b.imaginary)<Q.EPSILON},function(a,b){return Math.abs(a.real-b)<Q.EPSILON&&Math.abs(a.imaginary)<Q.EPSILON},function(a,b){return Math.abs(a.real-b.real)<Q.EPSILON&&Math.abs(a.imaginary-b.imaginary)<Q.EPSILON})},absolute:function(n){return Q.hypotenuse(n.real,n.imaginary)},conjugate:function(n){return new Q.ComplexNumber(n.real,n.imaginary*-1)},operate:function(name,a,b,numberAndNumber,numberAndComplex,complexAndNumber,complexAndComplex){if(Q.ComplexNumber.isNumberLike(a)){if(Q.ComplexNumber.isNumberLike(b))return numberAndNumber(a,b);else if(b instanceof Q.ComplexNumber)return numberAndComplex(a,b);else return Q.error("Q.ComplexNumber attempted to",name,"with the number",a,"and something that is neither a Number or Q.ComplexNumber:",b)}else if(a instanceof Q.ComplexNumber){if(Q.ComplexNumber.isNumberLike(b))return complexAndNumber(a,b);else if(b instanceof Q.ComplexNumber)return complexAndComplex(a,b);else return Q.error("Q.ComplexNumber attempted to",name,"with the complex number",a,"and something that is neither a Number or Q.ComplexNumber:",b)}else return Q.error("Q.ComplexNumber attempted to",name,"with something that is neither a Number or Q.ComplexNumber:",a)},sine:function(n){const a=n.real,b=n.imaginary;return new Q.ComplexNumber(Math.sin(a)*Q.hyperbolicCosine(b),Math.cos(a)*Q.hyperbolicSine(b))},cosine:function(n){const a=n.real,b=n.imaginary;return new Q.ComplexNumber(Math.cos(a)*Q.hyperbolicCosine(b),-Math.sin(a)*Q.hyperbolicSine(b))},arcCosine:function(n){const a=n.real,b=n.imaginary,t1=Q.ComplexNumber.squareRoot(new Q.ComplexNumber(b*b-a*a+1,a*b*-2)),t2=Q.ComplexNumber.log(new Q.ComplexNumber(t1.real-b,t1.imaginary+a));return new Q.ComplexNumber(Math.PI/2-t2.imaginary,t2.real)},arcTangent:function(n){const a=n.real,b=n.imaginary;if(a===0){if(b===1)return new Q.ComplexNumber(0,Infinity);if(b===-1)return new Q.ComplexNumber(0,-Infinity)}const d=a*a+(1-b)*(1-b),t=Q.ComplexNumber.log(new Q.ComplexNumber((1-b*b-a*a)/d,a/d*-2));return new Q.ComplexNumber(t.imaginary/2,t.real/2)},power:function(a,b){if(Q.ComplexNumber.isNumberLike(a))a=new Q.ComplexNumber(a);if(Q.ComplexNumber.isNumberLike(b))b=new Q.ComplexNumber(b);if(b.isZero())return Q.ComplexNumber.ONE;if(a.isZero()&&b.real>0&&b.imaginary>=0){return Q.ComplexNumber.ZERO}if(b.imaginary===0){if(a.real>=0&&a.imaginary===0){return new Q.ComplexNumber(Math.pow(a.real,b.real),0)}else if(a.real===0){switch((b.real%4+4)%4){case 0:return new Q.ComplexNumber(Math.pow(a.imaginary,b.real),0);case 1:return new Q.ComplexNumber(0,Math.pow(a.imaginary,b.real));case 2:return new Q.ComplexNumber(-Math.pow(a.imaginary,b.real),0);case 3:return new Q.ComplexNumber(0,-Math.pow(a.imaginary,b.real))}}}const arctangent2=Math.atan2(a.imaginary,a.real),logHypotenuse=Q.logHypotenuse(a.real,a.imaginary),x=Math.exp(b.real*logHypotenuse-b.imaginary*arctangent2),y=b.imaginary*logHypotenuse+b.real*arctangent2;return new Q.ComplexNumber(x*Math.cos(y),x*Math.sin(y))},squareRoot:function(a){const result=new Q.ComplexNumber(0,0),absolute=Q.ComplexNumber.absolute(a);if(a.real>=0){if(a.imaginary===0){result.real=Math.sqrt(a.real)}else{result.real=Math.sqrt(2*(absolute+a.real))/2}}else{result.real=Math.abs(a.imaginary)/Math.sqrt(2*(absolute-a.real))}if(a.real<=0){result.imaginary=Math.sqrt(2*(absolute-a.real))/2}else{result.imaginary=Math.abs(a.imaginary)/Math.sqrt(2*(absolute+a.real))}if(a.imaginary<0)result.imaginary*=-1;return result},log:function(a){return new Q.ComplexNumber(Q.logHypotenuse(a.real,a.imaginary),Math.atan2(a.imaginary,a.real))},multiply:function(a,b){return Q.ComplexNumber.operate("multiply",a,b,function(a,b){return new Q.ComplexNumber(a*b)},function(a,b){return new Q.ComplexNumber(a*b.real,a*b.imaginary)},function(a,b){return new Q.ComplexNumber(a.real*b,a.imaginary*b)},function(a,b){const firsts=a.real*b.real,outers=a.real*b.imaginary,inners=a.imaginary*b.real,lasts=a.imaginary*b.imaginary*-1;return new Q.ComplexNumber(firsts+lasts,outers+inners)})},divide:function(a,b){return Q.ComplexNumber.operate("multiply",a,b,function(a,b){return new Q.ComplexNumber(a/b)},function(a,b){return new Q.ComplexNumber(a).divide(b)},function(a,b){return new Q.ComplexNumber(a.real/b,a.imaginary/b)},function(a,b){const conjugate=b.conjugate(),numerator=a.multiply(conjugate),denominator=b.multiply(conjugate).real;return numerator.divide(denominator)})},add:function(a,b){return Q.ComplexNumber.operate("add",a,b,function(a,b){return new Q.ComplexNumber(a+b)},function(a,b){return new Q.ComplexNumber(b.real+a,b.imaginary)},function(a,b){return new Q.ComplexNumber(a.real+b,a.imaginary)},function(a,b){return new Q.ComplexNumber(a.real+b.real,a.imaginary+b.imaginary)})},subtract:function(a,b){return Q.ComplexNumber.operate("subtract",a,b,function(a,b){return new Q.ComplexNumber(a+b)},function(a,b){return new Q.ComplexNumber(b.real-a,b.imaginary)},function(a,b){return new Q.ComplexNumber(a.real-b,a.imaginary)},function(a,b){return new Q.ComplexNumber(a.real-b.real,a.imaginary-b.imaginary)})}});Q.ComplexNumber.createConstants("ZERO",new Q.ComplexNumber(0,0),"ONE",new Q.ComplexNumber(1,0),"E",new Q.ComplexNumber(Math.E,0),"PI",new Q.ComplexNumber(Math.PI,0),"I",new Q.ComplexNumber(0,1),"EPSILON",new Q.ComplexNumber(Q.EPSILON,Q.EPSILON),"INFINITY",new Q.ComplexNumber(Infinity,Infinity),"NAN",new Q.ComplexNumber(NaN,NaN));Object.assign(Q.ComplexNumber.prototype,{clone:function(){return new Q.ComplexNumber(this.real,this.imaginary)},reduce:function(){if(this.imaginary===0)return this.real;return this},isNaN:function(n){return Q.ComplexNumber.isNaN(this)},isZero:function(n){return Q.ComplexNumber.isZero(this)},isFinite:function(n){return Q.ComplexNumber.isFinite(this)},isInfinite:function(n){return Q.ComplexNumber.isInfinite(this)},isEqualTo:function(b){return Q.ComplexNumber.areEqual(this,b)},absolute:function(){return Q.ComplexNumber.absolute(this)},conjugate:function(){return Q.ComplexNumber.conjugate(this)},power:function(b){return Q.ComplexNumber.power(this,b)},squareRoot:function(){return Q.ComplexNumber.squareRoot(this)},log:function(){return Q.ComplexNumber.log(this)},multiply:function(b){return Q.ComplexNumber.multiply(this,b)},divide:function(b){return Q.ComplexNumber.divide(this,b)},add:function(b){return Q.ComplexNumber.add(this,b)},subtract:function(b){return Q.ComplexNumber.subtract(this,b)},toText:function(roundToDecimal){if(typeof roundToDecimal!=="number")roundToDecimal=16;const reduced=this.reduce(),imaginaryAbsolute=Math.abs(reduced.imaginary);if(Q.ComplexNumber.isNumberLike(reduced))return""+Q.round(reduced,roundToDecimal);if(reduced.real===0){if(reduced.imaginary===1)return"i";if(reduced.imaginary===-1)return"-i";return reduced.imaginary.toFixed(roundToDecimal)+"i"}return""+reduced.real.toFixed(roundToDecimal)+" "+(reduced.imaginary>=0?"+":"-")+" "+(imaginaryAbsolute===1?"i":Q.round(imaginaryAbsolute,roundToDecimal)+"i")},copy$:function(b){if(b instanceof Q.ComplexNumber!==true)return Q.error(`Q.ComplexNumber attempted to copy something that was not a complex number in to this complex number #${this.index}.`,this);this.real=b.real;this.imaginary=b.imaginary;return this},conjugate$:function(){return this.copy$(this.conjugate())},power$:function(b){return this.copy$(this.power(b))},squareRoot$:function(){return this.copy$(this.squareRoot())},log$:function(){return this.copy$(this.log())},multiply$:function(b){return this.copy$(this.multiply(b))},divide$:function(b){return this.copy$(this.divide(b))},add$:function(b){return this.copy$(this.add(b))},subtract$:function(b){return this.copy$(this.subtract(b))}});Q.Matrix=function(){`\n\tCreates a matrix of arbitrary dimensions. Expects an argument list of \n\tequal-length arrays where each array represents a row of column values. \n\tAutomatically determines matrix dimensions based on the number of \n\targuments (rows) and length of each row (number of columns). Throws an \n\terror if the row lengths are not equal.  \n\n\tLimitation: A matrix cannot change its dimensions after initialization \n\tand cannot contain matrices.  \n\t\n\n\t\tEXAMPLES  \n\n\tconst myMatrix = new Q.Matrix(  \n\t\t\n\t\t[ 1, 0, 0, 0 ],  \n\t\t[ 0, 1, 0, 0 ],  \n\t\t[ 0, 0, 0, 1 ],  \n\t\t[ 0, 0, 1, 0 ]  \n\t)  \n\n\t\n\t\tSEE ALSO  \n\n\thttps://en.wikipedia.org/wiki/Matrix_(mathematics)  \n\thttps://en.wikipedia.org/wiki/Row-_and_column-major_order\n\t\n\t`;this.index=Q.Matrix.index++;let matrixWidth=null,matrixWidthIsBroken=false;this.rows=Array.from(arguments);this.rows.forEach(function(row){if(row instanceof Array!==true)row=[row];if(matrixWidth===null)matrixWidth=row.length;else if(matrixWidth!==row.length)matrixWidthIsBroken=true});if(matrixWidthIsBroken)return Q.error(`Q.Matrix found upon initialization that matrix#${this.index} row lengths were not equal. You are going to have a bad time.`,this);const matrix=this;this.columns=[];for(let x=0;x<matrixWidth;x++){const column=[];for(let y=0;y<this.rows.length;y++){const value=matrix.rows[y][x];if(typeof value==="number"){matrix.rows[y][x]=new Q.ComplexNumber(value)}else if(value instanceof Q.ComplexNumber===false){return Q.error(`Q.Matrix found upon initialization that matrix#${this.index} contained non-quantitative values. A+ for creativity, but F for functionality.`,this)}Object.defineProperty(column,y,{get:function(){return matrix.rows[y][x]},set:function(n){matrix.rows[y][x]=n}})}this.columns.push(column)}};Object.assign(Q.Matrix,{index:0,help:function(){return Q.help(this)},constants:{},createConstant:Q.createConstant,createConstants:Q.createConstants,isMatrixLike:function(obj){return obj instanceof this||this.prototype.isPrototypeOf(obj)},isWithinRange:function(n,minimum,maximum){return typeof n==="number"&&n>=minimum&&n<=maximum&&n==parseInt(n)},getWidth:function(matrix){return matrix.columns.length},getHeight:function(matrix){return matrix.rows.length},haveEqualDimensions:function(matrix0,matrix1){return matrix0.rows.length===matrix1.rows.length&&matrix0.columns.length===matrix1.columns.length},createSquare:function(size,f){if(typeof size!=="number")size=2;if(typeof f!=="function")f=function(){return 0};const data=[];for(let y=0;y<size;y++){const row=[];for(let x=0;x<size;x++){row.push(f(x,y))}data.push(row)}return new Q.Matrix(...data)},createZero:function(size){return new Q.Matrix.createSquare(size)},createOne:function(size){return new Q.Matrix.createSquare(size,function(){return 1})},createIdentity:function(size){return new Q.Matrix.createSquare(size,function(x,y){return x===y?1:0})},from:function(format){if(typeof format!=="string")format="Array";format=format.toLowerCase();const f=Q.Matrix["from"+format];if(typeof f!=="function")return Q.error(`Q.Matrix could not find an importer for “${format}” data.`);return f()},fromArray:function(array){return new Q.Matrix(...array)},fromXsv:function(input,rowSeparator,valueSeparator){`\n\t\tIngest string data organized by row, then by column\n\t\twhere rows are separated by one token (default: \n)\n\t\tand column values are separated by another token\n\t\t(default: \t).\n\n\t\t`;if(typeof rowSeparator!=="string")rowSeparator="\n";if(typeof valueSeparator!=="string")valueSeparator="\t";const inputRows=input.split(rowSeparator),outputRows=[];inputRows.forEach(function(inputRow){inputRow=inputRow.trim();if(inputRow==="")return;const outputRow=[];inputRow.split(valueSeparator).forEach(function(cellValue){outputRow.push(parseFloat(cellValue))});outputRows.push(outputRow)});return new Q.Matrix(...outputRows)},fromCsv:function(csv){return Q.Matrix.fromXsv(csv.replace(/\r/g,"\n"),"\n",",")},fromTsv:function(tsv){return Q.Matrix.fromXsv(tsv,"\n","\t")},fromHtml:function(html){return Q.Matrix.fromXsv(html.replace(/\r?\n|\r|<tr>|<td>/g,"").replace(/<\/td>(\s*)<\/tr>/g,"</tr>").match(/<table>(.*)<\/table>/i)[1],"</tr>","</td>")},add:function(matrix0,matrix1){if(Q.Matrix.isMatrixLike(matrix0)!==true||Q.Matrix.isMatrixLike(matrix1)!==true){return Q.error(`Q.Matrix attempted to add something that was not a matrix.`)}if(Q.Matrix.haveEqualDimensions(matrix0,matrix1)!==true)return Q.error(`Q.Matrix cannot add matrix#${matrix0.index} of dimensions ${matrix0.columns.length}x${matrix0.rows.length} to matrix#${matrix1.index} of dimensions ${matrix1.columns.length}x${matrix1.rows.length}.`);return new Q.Matrix(...matrix0.rows.reduce(function(resultMatrixRow,row,r){resultMatrixRow.push(row.reduce(function(resultMatrixColumn,cellValue,c){resultMatrixColumn.push(cellValue.add(matrix1.rows[r][c]));return resultMatrixColumn},[]));return resultMatrixRow},[]))},multiplyScalar:function(matrix,scalar){if(Q.Matrix.isMatrixLike(matrix)!==true){return Q.error(`Q.Matrix attempted to scale something that was not a matrix.`)}if(typeof scalar!=="number"){return Q.error(`Q.Matrix attempted to scale this matrix#${matrix.index} by an invalid scalar: ${scalar}.`)}return new Q.Matrix(...matrix.rows.reduce(function(resultMatrixRow,row){resultMatrixRow.push(row.reduce(function(resultMatrixColumn,cellValue){resultMatrixColumn.push(cellValue.multiply(scalar));return resultMatrixColumn},[]));return resultMatrixRow},[]))},multiply:function(matrix0,matrix1){`\n\t\tTwo matrices can be multiplied only when \n\t\tthe number of columns in the first matrix\n\t\tequals the number of rows in the second matrix.\n\t\tReminder: Matrix multiplication is not commutative\n\t\tso the order in which you multiply matters.\n\n\n\t\t\tSEE ALSO\n\n\t\thttps://en.wikipedia.org/wiki/Matrix_multiplication\n\t\t`;if(Q.Matrix.isMatrixLike(matrix0)!==true||Q.Matrix.isMatrixLike(matrix1)!==true){return Q.error(`Q.Matrix attempted to multiply something that was not a matrix.`)}if(matrix0.columns.length!==matrix1.rows.length){return Q.error(`Q.Matrix attempted to multiply Matrix#${matrix0.index}(cols==${matrix0.columns.length}) by Matrix#${matrix1.index}(rows==${matrix1.rows.length}) but their dimensions were not compatible for this.`)}const resultMatrix=[];matrix0.rows.forEach(function(matrix0Row){const resultMatrixRow=[];matrix1.columns.forEach(function(matrix1Column){const sum=new Q.ComplexNumber;matrix1Column.forEach(function(matrix1CellValue,index){sum.add$(matrix0Row[index].multiply(matrix1CellValue))});resultMatrixRow.push(sum)});resultMatrix.push(resultMatrixRow)});return new this(...resultMatrix)},multiplyTensor:function(matrix0,matrix1){`\n\t\thttps://en.wikipedia.org/wiki/Kronecker_product\n\t\thttps://en.wikipedia.org/wiki/Tensor_product\n\t\t`;if(Q.Matrix.isMatrixLike(matrix0)!==true||Q.Matrix.isMatrixLike(matrix1)!==true){return Q.error(`Q.Matrix attempted to tensor something that was not a matrix.`)}const resultMatrix=[],resultMatrixWidth=matrix0.columns.length*matrix1.columns.length,resultMatrixHeight=matrix0.rows.length*matrix1.rows.length;for(let y=0;y<resultMatrixHeight;y++){const resultMatrixRow=[];for(let x=0;x<resultMatrixWidth;x++){const matrix0X=Math.floor(x/matrix0.columns.length),matrix0Y=Math.floor(y/matrix0.rows.length),matrix1X=x%matrix1.columns.length,matrix1Y=y%matrix1.rows.length;resultMatrixRow.push(matrix0.rows[matrix0Y][matrix0X].multiply(matrix1.rows[matrix1Y][matrix1X]))}resultMatrix.push(resultMatrixRow)}return new Q.Matrix(...resultMatrix)}});Object.assign(Q.Matrix.prototype,{isValidRow:function(r){return Q.Matrix.isWithinRange(r,0,this.rows.length-1)},isValidColumn:function(c){return Q.Matrix.isWithinRange(c,0,this.columns.length-1)},isValidAddress:function(x,y){return this.isValidRow(y)&&this.isValidColumn(x)},getWidth:function(){return Q.Matrix.getWidth(this)},getHeight:function(){return Q.Matrix.getHeight(this)},read:function(x,y){`\n\t\tEquivalent to \n\t\tthis.columns[ x ][ y ] \n\t\tor \n\t\tthis.rows[ y ][ x ]\n\t\tbut with safety checks.\n\t\t`;if(this.isValidAddress(x,y))return this.rows[y][x];return Q.error(`Q.Matrix could not read from cell address (x=${x}, y=${y}) in matrix#${this.index}.`,this)},clone:function(){return new Q.Matrix(...this.rows)},toArray:function(){return this.rows},toXsv:function(rowSeparator,valueSeparator){return this.rows.reduce(function(xsv,row){return xsv+rowSeparator+row.reduce(function(xsv,cell,c){return xsv+(c>0?valueSeparator:"")+cell.toText()},"")},"")},toCsv:function(){`\n\t\tCreates a comma-separated-values table and returns it as a string.\n\t\t`;return this.toXsv("\n",",")},toTsv:function(){`\n\t\tCreates a tab-separated-values table and returns it as a string.\n\t\t`;return this.toXsv("\n","\t")},toHtml:function(){`\n\t\tCreates HTML table code and returns it as a string.\n\t\t`;return this.rows.reduce(function(html,row){return html+row.reduce(function(html,cell){return html+"\n\t\t<td>"+cell.toText()+"</td>"},"\n\t<tr>")+"\n\t</tr>"},"\n<table>")+"\n</table>"},write$:function(x,y,n){`\n\t\tEquivalent to \n\t\tthis.columns[ x ][ y ] = n \n\t\tor \n\t\tthis.rows[ y ][ x ] = n\n\t\tbut with safety checks.\n\t\t`;if(this.isValidAddress(x,y)){if(typeof n!=="number")return Q.error(`Attempted to write an invalid value (${n}) to matrix#${this.index} at x=${x}, y=${y}`,this);this.rows[y][x]=n;return this}return Q.error(`Invalid cell address for Matrix#${this.index}: x=${x}, y=${y}`,this)},copy$:function(matrix){if(Q.Matrix.isMatrixLike(matrix)!==true)return Q.error(`Q.Matrix attempted to copy something that was not a matrix in to this matrix#${matrix.index}.`,this);if(Q.Matrix.haveEqualDimensions(matrix,this)!==true)return Q.error(`Q.Matrix cannot copy matrix#${matrix.index} of dimensions ${matrix.columns.length}x${matrix.rows.length} in to this matrix#${this.index} of dimensions ${this.columns.length}x${this.rows.length} because their dimensions do not match.`,this);const that=this;matrix.rows.forEach(function(row,r){row.forEach(function(n,c){that.rows[r][c]=n})});return this},fromArray$:function(array){return this.copy$(Q.Matrix.fromArray(array))},fromCsv$:function(csv){return this.copy$(Q.Matrix.fromCsv(csv))},fromTsv$:function(tsv){return this.copy$(Q.Matrix.fromTsv(tsv))},fromHtml$:function(html){return this.copy$(Q.Matrix.fromHtml(html))},add:function(otherMatrix){return Q.Matrix.add(this,otherMatrix)},multiplyScalar:function(scalar){return Q.Matrix.multiplyScalar(this,scalar)},multiply:function(otherMatrix){return Q.Matrix.multiply(this,otherMatrix)},multiplyTensor:function(otherMatrix){return Q.Matrix.multiplyTensor(this,otherMatrix)},add$:function(otherMatrix){return this.copy$(this.add(otherMatrix))},multiplyScalar$:function(scalar){return this.copy$(this.multiplyScalar(scalar))}});Q.Matrix.createConstants("IDENTITY_2X2",Q.Matrix.createIdentity(2),"IDENTITY_3X3",Q.Matrix.createIdentity(3),"IDENTITY_4X4",Q.Matrix.createIdentity(4),"CONSTANT0_2X2",new Q.Matrix([1,1],[0,0]),"CONSTANT1_2X2",new Q.Matrix([0,0],[1,1]),"NEGATION_2X2",new Q.Matrix([0,1],[1,0]),"TEST_MAP_9X9",new Q.Matrix([11,21,31,41,51,61,71,81,91],[12,22,32,42,52,62,72,82,92],[13,23,33,43,53,63,73,83,93],[14,24,34,44,54,64,74,84,94],[15,25,35,45,55,65,75,85,95],[16,26,36,46,56,66,76,86,96],[17,27,37,47,57,67,77,87,97],[18,28,38,48,58,68,78,88,98],[19,29,39,49,59,69,79,89,99]),"HADAMARD",new Q.Matrix([Math.SQRT1_2,Math.SQRT1_2],[Math.SQRT1_2,-Math.SQRT1_2]),"PAULI_X",new Q.Matrix([0,1],[1,0]),"PAULI_Y",new Q.Matrix([0,new Q.ComplexNumber(0,-1)],[new Q.ComplexNumber(0,1),0]),"PAULI_Z",new Q.Matrix([1,0],[0,-1]),"PHASE",new Q.Matrix([1,0],[0,new Q.ComplexNumber(0,1)]),"PI_8",new Q.Matrix([1,0],[0,Q.ComplexNumber.E.power(new Q.ComplexNumber(0,Math.PI/4))]),"CONTROLLED_NOT",new Q.Matrix([1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]),"SWAP",new Q.Matrix([1,0,0,0],[0,0,1,0],[0,1,0,0],[0,0,0,1]),"CONTROLLED_Z",new Q.Matrix([1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,-1]),"CONTROLLED_PHASE",new Q.Matrix([1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,new Q.ComplexNumber(0,1)]),"TOFFOLI",new Q.Matrix([1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,1,0]),"CONTROLLED_SWAP",new Q.Matrix([1,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1]));Q.Qubit=function(a,b,label,name){`\n\tA qubit is represented by Q.Matrix([ 𝒂 ],[ 𝒃 ]) where 𝒂 and 𝒃 are “complex \n\tnumbers” such that |𝒂| × |𝒂| + |𝒃| × |𝒃| = 1. If brevity’s your thing, that’s the \n\tsame as |𝒂|² + |𝒃|² = 1. https://en.wikipedia.org/wiki/Qubit  \n\n\n\t  EXAMPLE  \n\n\t  const ourQubit = new Q.Qubit( 0, 1 )  \n\n\n\tOur 𝒂 argument represents our qubit’s “control bit” while our 𝒃 argument \n\trepresents our quibit’s “target bit”—the part we are ultimately concerned \n\twith. A qubit may be in superposition, ie.  its target bit is neither 0 \n\tor 1 and computationally exists as both 0 and 1 at the same time. The \n\tprobability that the qubit will “collapse” to 0 is 𝒂², while the \n\tprobability that the qubit will “collapse” to 1 is 𝒃². \n\thttps://en.wikipedia.org/wiki/Quantum_superposition   \n\t\n\n\t\tEXAMPLES  \n\t\n\t• Qubit( 1, 0 ) has a 100% chance of collapsing to 0.  \n\t• Qubit( 0, 1 ) has a 100% chance of collapsing to 1.  \n\t• Qubit( 1÷√2, 1÷√2 ) has a 50% chance of collapsing to 0 and a 50% \n\tchance of collapsing to 1.  \n\n\n\t\tBLOCH SPHERE  \n\n\tIf we plot all of the possible values for 𝒂 and 𝒃 on a standard graph \n\tit will create a circle with a radius of 1 centered at the origin (0, 0); \n\tie. a unit circle. This is the result of our rule that 𝒂² + 𝒃² = 1. \n\thttps://en.wikipedia.org/wiki/Unit_circle).  \n\t\n\t             \n\t               ( 0, 1 )  Vertical   \n\t                   │  \n\t   ( -1÷√2, 1÷√2 ) │ ( 1÷√2, 1÷√2 )  Diagonal  \n\t                ╲  │  ╱  \n\t                 ╲ │ ╱  \n\t                  ╲│╱   \n\t  ( -1, 0 )────────╳────────( 1, 0 )  Horizontal  \n\t                  ╱│╲  \n\t                 ╱ │ ╲   \n\t                ╱  │  ╲  \n\t  ( -1÷√2, -1÷√2 ) │ ( 1÷√2, -1÷√2 )  Anti-diagonal  \n\t                   │  \n\t                   │  \n\t               ( 0, -1 )  \n\n\n\tIf we allow for complex numbers like 𝒊 then our 2D circle becomes a 3D \n\tBloch sphere. Our unit circle or unit sphere can be used as a state \n\tmachine for quantum compuation, though Q.js currently focusses on \n\tmatrices for calculation. \n\thttps://en.wikipedia.org/wiki/Bloch_sphere  \n\t\n\n\t\tCONSTANTS  \n\n\tQ.Qubit provides the following built-in Jones vectors. \n\thttps://en.wikipedia.org/wiki/Jones_calculus#Jones_vectors  \n\t• HORIZONTAL = new Q.Qubit( 1, 0 )  \n\t• VERTICAL   = new Q.Qubit( 0, 1 )  \n\t• DIAGONAL      = new Q.Qubit( 1÷√2,  1÷√2 )  \n\t• ANTI_DIAGONAL = new Q.Qubit( 1÷√2, -1÷√2 )  \n\t• RIGHT_HAND_CIRCULAR_POLARIZED = new Q.Qubit( 1÷√2, -1÷√2𝒊 )  \n\t• LEFT_HAND_CIRCULAR_POLARIZED  = new Q.Qubit( 1÷√2,  1÷√2𝒊 )  \n\t\n\t`;if(Q.Matrix.isMatrixLike(a)&&b===undefined){b=a.rows[1][0];a=a.rows[0][0]}else{if(typeof a==="number")a=new Q.ComplexNumber(a,0);if(typeof b==="number")b=new Q.ComplexNumber(b,0);if(a instanceof Q.ComplexNumber!==true)a=new Q.ComplexNumber(1,0);if(b instanceof Q.ComplexNumber!==true){b=Q.ComplexNumber.ONE.subtract(Math.pow(a.absolute(),2)).squareRoot()}}if(Math.pow(a.absolute(),2)+Math.pow(b.absolute(),2)-1>Q.EPSILON)return Q.error(`Q.Qubit could not accept the initialization values of a=${a} and b=${b} because their squares do not add up to 1.`);Q.Matrix.call(this,[a],[b]);this.index=Q.Qubit.index++;Object.defineProperty(this,"bra",{get:function(){return this.rows[0][0]},set:function(n){this.rows[0][0]=n}});Object.defineProperty(this,"ket",{get:function(){return this.rows[1][0]},set:function(n){this.rows[1][0]=n}});if(typeof label==="string")this.label=label;if(typeof name==="string")this.name=name;if(this.label===undefined||this.name===undefined){const found=Object.values(Q.Qubit.constants).find(function(qubit){return a.isEqualTo(qubit.bra)&&b.isEqualTo(qubit.ket)});if(found===undefined){this.label="?";this.name="Unnamed"}else{if(this.label===undefined)this.label=found.label;if(this.name===undefined)this.name=found.name}}};Q.Qubit.prototype=Object.create(Q.Matrix.prototype);Q.Qubit.prototype.constructor=Q.Qubit;Object.assign(Q.Qubit,{index:0,help:function(){return Q.help(this)},constants:{},createConstant:Q.createConstant,createConstants:Q.createConstants,findByKet:function(ket){if(ket instanceof Q.ComplexNumber===false){ket=new Q.ComplexNumber(ket)}return Object.values(Q.Qubit.constants).find(function(qubit){return qubit.ket.isEqualTo(ket)})},areEqual:function(qubit0,qubit1){return qubit0.bra.isEqualTo(qubit0.bra)&&qubit1.ket.isEqualTo(qubit1.ket)},collapse:function(qubit){const bra2=Math.pow(qubit.bra.absolute(),2),ket2=Math.pow(qubit.ket.absolute(),2),randomNumberRange=Math.pow(2,32)-1,randomNumber=new Uint32Array(1);window.crypto.getRandomValues(randomNumber);const randomNumberNormalized=randomNumber/randomNumberRange;if(randomNumberNormalized<=bra2){return new Q.Qubit(1,0)}else return new Q.Qubit(0,1)},applyGate:function(qubit,gate){`\n\t\tThis is means of inverting what comes first:\n\t\tthe Gate or the Qubit?\n\t\tIf the Gate only operates on a single qubit,\n\t\tthen it doesn’t matter and we can do this:\n\t\t`;if(gate instanceof Q.Gate===false)return Q.error(`Q.Qubit attempted to apply something that was not a gate to this qubit #${qubit.index}.`);else return gate.applyTo(qubit)},toText:function(qubit){return qubit.bra.toText()+"\n"+qubit.ket.toText()},toBlochSphere:function(qubit){`\n\t\tBased on this qubit’s state return the\n\t\tPolar angle θ (theta),\n\t\tazimuth angle ϕ (phi),\n\t\tBloch vector,\n\t\tcorrected surface coordinate.\n\n\t\thttps://en.wikipedia.org/wiki/Bloch_sphere\n\t\t`;const theta=Q.ComplexNumber.arcCosine(qubit.bra).multiply(2);if(isNaN(theta.real))theta.real=0;if(isNaN(theta.imaginary))theta.imaginary=0;const phi=Q.ComplexNumber.log(qubit.ket.divide(Q.ComplexNumber.sine(theta.divide(2)))).divide(Q.ComplexNumber.I);if(isNaN(phi.real))phi.real=0;if(isNaN(phi.imaginary))phi.imaginary=0;const vector={x:Q.ComplexNumber.sine(theta).multiply(Q.ComplexNumber.cosine(phi)).real,y:Q.ComplexNumber.sine(theta).multiply(Q.ComplexNumber.sine(phi)).real,z:Q.ComplexNumber.cosine(theta).real};const position={x:vector.y,y:vector.z,z:vector.x};return{theta:theta.real,phi:phi.real,vector:vector,position:position}},fromBlochVector:function(x,y,z){}});Q.Qubit.createConstants("HORIZONTAL",new Q.Qubit(1,0,"H","Horizontal"),"VERTICAL",new Q.Qubit(0,1,"V","Vertical"),"DIAGONAL",new Q.Qubit(Math.SQRT1_2,Math.SQRT1_2,"D","Diagonal"),"ANTI_DIAGONAL",new Q.Qubit(Math.SQRT1_2,-Math.SQRT1_2,"A","Anti-diagonal"),"RIGHT_HAND_CIRCULAR_POLARIZED",new Q.Qubit(Math.SQRT1_2,new Q.ComplexNumber(0,-Math.SQRT1_2),"R","Right-hand Circular Polarized"),"LEFT_HAND_CIRCULAR_POLARIZED",new Q.Qubit(Math.SQRT1_2,new Q.ComplexNumber(0,Math.SQRT1_2),"L","Left-hand Circular Polarized"));Object.assign(Q.Qubit.prototype,{copy$:function(matrix){if(Q.Matrix.isMatrixLike(matrix)!==true)return Q.error(`Q.Qubit attempted to copy something that was not a matrix in this qubit #${qubit.index}.`,this);if(Q.Matrix.haveEqualDimensions(matrix,this)!==true)return Q.error(`Q.Qubit cannot copy matrix#${matrix.index} of dimensions ${matrix.columns.length}x${matrix.rows.length} in to this qubit #${this.index} of dimensions ${this.columns.length}x${this.rows.length} because their dimensions do not match.`,this);const that=this;matrix.rows.forEach(function(row,r){row.forEach(function(n,c){that.rows[r][c]=n})});this.dirac=matrix.dirac;return this},isEqualTo:function(otherQubit){return Q.Qubit.areEqual(this,otherQubit)},collapse:function(){return Q.Qubit.collapse(this)},applyGate:function(gate){return Q.Qubit.applyGate(this,gate)},toText:function(){return Q.Qubit.toText(this)},toBlochSphere:function(){return Q.Qubit.toBlochSphere(this)},collapse$:function(){return this.copy$(Q.Qubit.collapse(this))},applyGate$:function(gate){return this.copy$(Q.Qubit.applyGate(this,gate))}});Q.Gate=function(operation,label,name){`\n\t\n\t\tSEE ALSO\n\t\n\thttps://en.wikipedia.org/wiki/Quantum_logic_gate\n\t`;this.index=Q.Gate.index++;this.label=typeof label==="string"?label:"g";this.name=typeof name==="string"?name:"Unlabeled";this.applyTo=typeof operation==="function"?operation:function(){Q.warn(`Gate #${this.index} (“${this.name}”) has no operation function.`)}};Object.assign(Q.Gate,{index:0,help:function(){return Q.help(this)},constants:{},createConstant:Q.createConstant,createConstants:Q.createConstants,findByLabel:function(label){return Object.values(Q.Gate.constants).find(function(element){return element.label.toUpperCase()===label.toUpperCase()})},findByName:function(label){return Object.values(Q.Gate.constants).find(function(element){return element.name.toUpperCase()===name.toUpperCase()})}});Q.Gate.createConstants("IDENTITY",new Q.Gate(function(qubit){return qubit},"I","Identity"),"MEASURE",new Q.Gate(function(qubit){return qubit.collapse()},"M","Measure"),"HADAMARD",new Q.Gate(function(qubit){return new Q.Qubit(Q.Matrix.HADAMARD.multiply(qubit))},"H","Hadamard"),"PAULI_X",new Q.Gate(function(qubit){return new Q.Qubit(Q.Matrix.PAULI_X.multiply(qubit))},"X","Pauli X"),"PAULI_Y",new Q.Gate(function(qubit){return new Q.Qubit(Q.Matrix.PAULI_Y.multiply(qubit))},"Y","Pauli Y"),"PAULI_Z",new Q.Gate(function(qubit){return new Q.Qubit(Q.Matrix.PAULI_Z.multiply(qubit))},"Z","Pauli Z"),"PHASE",new Q.Gate(function(qubit){return new Q.Qubit(Q.Matrix.PHASE.multiply(qubit))},"S","Phase"),"PI_8",new Q.Gate(function(qubit){return new Q.Qubit(Q.Matrix.PI_8.multiply(qubit))},"T","π ÷ 8"),"CONTROLLED_NOT",new Q.Gate(function(controlQubit,targetQubit){const result=Q.Matrix.CONTROLLED_NOT.multiply(targetQubit.multiplyTensor(controlQubit));return[new Q.Qubit(result.rows[0][0],result.rows[1][0]),new Q.Qubit(result.rows[2][0],result.rows[3][0])]},"C","Controlled Not (C-Not)"),"BLOCH_SPHERE",new Q.Gate(function(qubit){},"B","Bloch Sphere visualizer"));Object.assign(Q.Gate.prototype,{clone:function(){return new Q.Gate(this.applyTo,this.label,this.name)},toText:function(){return`-${this.label}-`},toDiagram:function(){},toHtml:function(){return`<div class="gate">${this.label}</div>`}});Q.Program=function(bandwidth,timewidth){if(typeof bandwidth!=="number")bandwidth=3;this.bandwidth=bandwidth;if(typeof timewidth!=="number")timewidth=6;timewidth+=1;this.timewidth=timewidth;this.moments=new Array(timewidth).fill(new Array(bandwidth).fill(Q.Qubit.HORIZONTAL,0,bandwidth),0,1);for(let m=1;m<this.moments.length;m++){this.moments[m]=new Array(bandwidth).fill(Q.Gate.IDENTITY,0,bandwidth)}};Object.assign(Q.Program,{index:0,help:function(){return Q.help(this)},constants:{},createConstant:Q.createConstant,createConstants:Q.createConstants,fromText:function(text){if(text.raw!==undefined)text=""+text.raw;const linesRaw=text.split("\n"),lines=linesRaw.reduce(function(cleaned,line){const trimmed=line.trim();if(trimmed.length)cleaned.push(trimmed.toUpperCase().split(""));return cleaned},[]),bandwidth=lines.length;const timewidth=lines[0].length;lines.forEach(function(line,l){if(line.length!==timewidth)return Q.error(`Q.Program attempted to create a new program from text input but the amount of time implied in the submitted text is not consistent.`)});const p=new Q.Program(bandwidth,timewidth);lines.forEach(function(line,l){line.forEach(function(moment,m){const node=new Q.Gate.findByLabel(moment);if(node instanceof Q.Gate!==true)return Q.error(`Q.Program attempted to create a new program from text input but could not identify this submitted gate: ${moment}.`);p.set(m+1,l,node)})});return p},fromTextOLD:function(text){if(text.raw!==undefined)text=""+text.raw;const linesRaw=text.split("\n"),lines=linesRaw.reduce(function(cleaned,line){const trimmed=line.trim();if(trimmed.length){cleaned.push(trimmed.replace(/--/g,"-").split("-"))}return cleaned},[]),bandwidth=lines.length;const timewidth=lines[0].length;const p=new Q.Program(bandwidth,timewidth);lines.forEach(function(line,l){line.forEach(function(moment,m){let node;if(moment.substr(0,1)==="|"){moment=+moment.substr(1,moment.length-2);node=Q.Qubit.findByKet(moment)}else node=new Q.Gate.findByLabel(moment);p.set(m,l,node)})});return p},copy:function(){},cut:function(){},paste:function(){},getMoment:function(){return{to:function(moment){}}}});Object.assign(Q.Program.prototype,{set:function(momentIndex,qubitIndex,value){this.moments[momentIndex][qubitIndex]=value},run:function(){const state=this.moments[0].slice(0);for(let m=1;m<this.timewidth;m++){for(let b=0;b<this.bandwidth;b++){state[b]=this.moments[m][b].applyTo(state[b])}}for(let s=0;s<state.length;s++){state[s]=state[s].collapse().ket.toText()}return"|"+state.join("")+"⟩"},toText:function(){const that=this,graph=new Array(this.bandwidth).fill("");this.moments.forEach(function(moment,m){moment.forEach(function(node,n){let label="";if(node instanceof Q.Qubit)label="|"+node.ket.toText()+"⟩";else{label="-"+node.label;if(m<that.moments.length-1)label+="-"}graph[n]+=label})});return graph.join("\n")},toDiagram:function(){const that=this,graph=new Array(this.bandwidth*3+1).fill("");this.moments.forEach(function(moment,m){if(m===0){graph[0]="\n "}graph[0]+="   t"+m;moment.forEach(function(node,n){let first="",second="",third="";if(m===0){first="    ",second="q"+n+"  ",third="    "}if(node instanceof Q.Qubit){first+="    ";second+="|"+node.ket.toText()+"⟩─";third+="    "}else{if(node.label==="I"){first+="   ";second+="──○";third+="   ";if(m<that.moments.length-1){first+="  ";second+="──";third+="  "}}else{first+="┌───┐";second+="┤ "+node.label+" ";third+="└───┘";if(m<that.moments.length-1)second+="├";else second+="│"}}graph[n*3+1]+=first;graph[n*3+2]+=second;graph[n*3+3]+=third})});return graph.join("\n")},toDom:function(){const programElement=document.createElement("div");programElement.classList.add("program")}});var p=new Q.Program;p.set(0,0,Q.Qubit.HORIZONTAL);p.set(0,1,Q.Qubit.VERTICAL);p.set(0,2,Q.Qubit.VERTICAL);p.set(1,0,Q.Gate.HADAMARD);p.set(2,0,Q.Gate.PAULI_X);p.set(3,0,Q.Gate.PAULI_Y);p.set(4,0,Q.Gate.PAULI_Z);p.set(1,1,Q.Gate.HADAMARD);p.set(2,1,Q.Gate.PHASE);p.set(3,1,Q.Gate.PI_8);p.set(1,2,Q.Gate.HADAMARD);
