<!DOCTYPE html>
<html>
	<head>
		<title>Q.js</title>
		<meta charset="utf-8">
		<meta name="viewport"             content="width=device-width,initial-scale=1.0">
		<meta name="description"          content="Q.js is quantum computing in your browser.">
		
		<!-- meta name="twitter:card"         content="summary">
		<meta name="twitter:site"         content="@stew_rtsmith">
		<meta name="twitter:creator"      content="@stew_rtsmith">
		<meta name="twitter:description"  content="Q.js is quantum computing in your browser.">
		<meta name="twitter:title"        content="Q.js">
		<meta name="twitter:image"        content="">
		<meta name="twitter:url"          content="https://github.com/stewdio/q.js">
		
		<meta property="og:type"          content="website">
		<meta property="og:description"   content="Q.js is quantum computing in your browser.">
		<meta property="og:title"         content="Q.js">
		<meta property="og:image"         content="">
		<meta property="og:url"           content="https://github.com/stewdio/q.js" -->
		
		<!-- link rel="canonical"             href="http://">
		<link rel="icon" type="image/png" href="media/favicon-064.png">
		<link rel="apple-touch-icon"      href="media/favicon-144.png" -->
		<link rel="stylesheet" type="text/css" href="style.css">
		
		<script src="Q/Q.js"></script>
		<script src="Q/Matrix.js"></script>
		<script src="Q/Qubit.js"></script>
		<script src="Q/Gate.js"></script>
	</head>
	<body>

		<strong>Q.js is quantum computing in your browser.</strong><br>
		Right now all the action is in your JavaScript console,<br>
		so open that up!
		<script>




console.log( '\n\nQ.Matrix\n', Q.extractDocumentation( Q.Matrix ), '\n\n' )
console.log( '\n\nQ.Qubit\n', Q.extractDocumentation( Q.Qubit ), '\n\n' )




//  Qubit logical tensor products.

var qubit0 = new Q.Matrix(
	[ 1 ],
	[ 0 ])

var qubit1 = new Q.Matrix(
	[ 0 ],
	[ 1 ])

console.log( '0 ⊗ 0 =', qubit0.multiplyTensor( qubit0 ).toTSV(), '\n\n' )
console.log( '0 ⊗ 1 =', qubit0.multiplyTensor( qubit1 ).toTSV(), '\n\n' )
console.log( '1 ⊗ 0 =', qubit1.multiplyTensor( qubit0 ).toTSV(), '\n\n' )
console.log( '1 ⊗ 1 =', qubit1.multiplyTensor( qubit1 ).toTSV(), '\n\n' )




//  More complex tensor product.

var matrixA = new Q.Matrix(
	[ 1, 2 ],
	[ 3, 4 ])
console.log( 'Matrix A =', matrixA.toTSV(), '\n\n' )

var matrixB = new Q.Matrix(
	[ 0, 5 ],
	[ 6, 7 ])
console.log( 'Matrix B =', matrixB.toTSV(), '\n\n' )

console.log( 'Matrix A ⊗ Matrix B =', matrixA.multiplyTensor( matrixB ).toTSV(), '\n\n' )




/*
console.log( '\n\nQ.Matrix\n', Q.extractDocumentation( Q.Matrix ), '\n\n' )
console.log( '\n\nQ.Matrix.prototype.multiply\n', Q.extractDocumentation( Q.Matrix.prototype.multiply ), '\n\n' )


console.log( 'Q.Matrix.IDENTITY_2X2', Q.Matrix.IDENTITY_2X2 )
console.log( 'Q.Matrix.IDENTITY_3X3', Q.Matrix.IDENTITY_3X3 )
console.log( 'Q.Matrix.IDENTITY_4X4', Q.Matrix.IDENTITY_4X4 )


console.log( 'Q.Matrix.CNOT', Q.Matrix.CNOT )
console.log( '\nQ.Matrix.CNOT.toHtml()', Q.Matrix.CNOT.toHTML(), '\n\n' )
console.log( '\nQ.Matrix.TEST_MAP_9X9.toCSV()', Q.Matrix.TEST_MAP_9X9.toCSV(), '\n\n' )
console.log( '\nQ.Matrix.TEST_MAP_9X9.toTSV()', Q.Matrix.TEST_MAP_9X9.toTSV(), '\n\n' )


console.log( 'How many matrices have we created?', Q.Matrix.index )
*/


/*
var a = new Q.Matrix(
	[ 2, 2, 2 ],
	[ 2, 2, 2 ],
	[ 2, 2, 2 ])

var b = new Q.Matrix(
	[ 3 ],
	[ 3 ],
	[ 3 ])

console.log( 'a.multiply( b ).toTSV()', a.multiply( b ).toTSV() )




var c = new Q.Matrix(
	[ 1, 2, 3 ],
	[ 4, 5, 6 ],
	[ 7, 8, 9 ])

var d = new Q.Matrix(
	[ 1 ],
	[ 2 ],
	[ 3 ])

console.log( 'c.multiply( d ).toTSV()', c.multiply( d ).toTSV() )



var e = new Q.Matrix(
	[ 1, 2 ],
	[ 3, 4 ])

var f = new Q.Matrix(
	[ 1, 2 ],
	[ 3, 4 ])

console.log( 'e.multiply( df ).toTSV()', e.multiply( f ).toTSV() )





var twos = new Q.Matrix(
	[ 2, 2, 2 ],
	[ 2, 2, 2 ],
	[ 2, 2, 2 ])

var threes = new Q.Matrix(
	[ 3, 3, 3 ],
	[ 3, 3, 3 ],
	[ 3, 3, 3 ])


console.log( 'Q.Matrix.IDENTITY_2X2.multiply( e ).toTSV()', Q.Matrix.IDENTITY_2X2.multiply( e ))
console.log( 'Q.Matrix.IDENTITY_3X3.multiply( c ).toTSV()', Q.Matrix.IDENTITY_3X3.multiply( c ))
*/



/*

var a = new Q.Matrix(
	[ 1, 2 ],
	[ 3, 4 ])

var b = new Q.Matrix(
	[ 0, 5 ],
	[ 6, 7 ])

// console.log( 'a.multiplyTensor( b )', a.multiplyTensor( b ))

*/





//  Import and export formats.

var csv = Q.Matrix.fromCSV(`
	1, 2, 3
	4, 5, 6
	7, 8, 9`)
console.log( 'Matrix from CSV', csv.toTSV(), '\n\n' )


var tsv = Q.Matrix.fromTSV(`1	2	3
4	5	6
7	8	9`)
console.log( 'Matrix from TSV', tsv.toTSV(), '\n\n' )


const html = `
<table>
	<tr>
		<td>1</td>
		<td>2</td>
		<td>3</td>
	</tr>
	<tr>
		<td>4</td>
		<td>5</td>
		<td>6</td>
	</tr>
	<tr>
		<td>7</td>
		<td>8</td>
		<td>9</td>
	</tr>
</table> `

console.log( 'Matrix from HTML', Q.Matrix.fromHTML( html ).toTSV(), '\n\n' )




//  Superposition via Hadamard gate.

console.log( '\n\n\n\nSUPERPOSITION' )

console.log( '\nLet’s start with a simple horizontal qubit, `Q.Qubit.HORIZONTAL`:', Q.Qubit.HORIZONTAL.toTSV() )

console.log( '\nWe’ve got a Hadamard gate handy, `Q.Gate.HADAMARD`:', Q.Gate.HADAMARD.toTSV() )

console.log( '\nAnd now let’s apply that Hadamard gate to our qubit:' )
console.log( 'Q.Gate.HADAMARD.applyTo( Q.Qubit.HORIZONTAL )', Q.Gate.HADAMARD.applyTo( Q.Qubit.HORIZONTAL ).toTSV() )

console.log( '\nOur `h` qubit is now in superposition!' )

console.log( '\nHere’s how to put a qubit in to superposition, then collapse it, all in one go, ie. the most superfluous coin flip routine of all time:' )
console.log( 'Q.Gate.HADAMARD.applyTo( Q.Qubit.HORIZONTAL ).collapse()', Q.Gate.HADAMARD.applyTo( Q.Qubit.HORIZONTAL ).collapse().toTSV() )

console.log( '\nSometimes that will produce (0,1), sometimes (1,0). Yay for [fake] quantum!\n\n')



		</script>
	</body>
</html>