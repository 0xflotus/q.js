<!DOCTYPE html>
<html>
	<head>
		<title>Q ⟩ Qubit</title>
		<meta charset="utf-8">
		<meta name="description"          content="Q.js is quantum computing in your browser.">
		<meta name="copyright"            content="Stewart Smith 2019">
		<meta name="keywords"             content="

			quantum, quantum physics, quantum mechanics, superposition,
			quantum computer, quantum computing, qubit, qbit, gate, Hadamard,

			Google, Microsoft, IBM, DWave, D-Wave, NASA,
			Quil, OpenQASM,
			ProjectQ, Qiskit, 
			Quantum Development Kit, Cirq, Strawberry Fields, t|ket>,
			QCL, Quantum pseudocode, Q#, Q|SI>, Q language, qGCL, QFC, QML, LIQUi|>, Quipper,

			Web, Web site, website, Web browser, browser, HTML, HTML5, JavaScript, ES6, CSS,

			Stewart Smith, Stewart, Stew, Stuart, Steven, Steve, Stewdio, stew_rtsmith, @stew_rtsmith,
			Moar, Moar Technologies Corp, MTC,">

		<meta name="twitter:card"         content="summary">
		<meta name="twitter:site"         content="@stew_rtsmith">
		<meta name="twitter:creator"      content="@stew_rtsmith">
		<meta name="twitter:description"  content="Quantum computing in your browser.">
		<meta name="twitter:title"        content="Q ⟩ Qubit">
		<meta name="twitter:image"        content="https://stewdio.github.io/q.js/Assets/q-thumbnail.png">
		<meta name="twitter:url"          content="https://stewdio.github.io/q.js/">
		
		<meta property="og:type"          content="website">
		<meta property="og:description"   content="Quantum computing in your browser.">
		<meta property="og:title"         content="Q ⟩ Qubit">
		<meta property="og:image"         content="https://stewdio.github.io/q.js/Assets/q-thumbnail.png">
		<meta property="og:url"           content="http://stewartsmith.io">
		
		<link rel="canonical"             href="https://stewdio.github.io/q.js/Qubit.html">
		<link rel="icon" type="image/png" href="Assets/q-favicon-064.png">
		<link rel="apple-touch-icon"      href="Assets/q-favicon-144.png">
		<link rel="stylesheet" type="text/css" href="Assets/style.css">
		
		<script src="Q/Q.js"></script>
		<script src="Q/ComplexNumber.js"></script>
		<script src="Q/Matrix.js"></script>
		<script src="Q/Qubit.js"></script>
		<script src="Q/Gate.js"></script>
		<script src="Q/Circuit.js"></script>
		<script src="Assets/navigation.js"></script>
		
		<script src="Assets/Three/three.105.min.js"></script>
		<script src="Assets/Three/OrbitControls.js"></script>
		<!--
		<script src="Assets/Three/LineSegmentsGeometry.js"></script>
		<script src="Assets/Three/LineGeometry.js"></script>
		<script src="Assets/Three/LineMaterial.js"></script>
		<script src="Assets/Three/LineSegments2.js"></script>
		<script src="Assets/Three/Line2.js"></script>
		-->
		<script src="Assets/Tween/tween.min.js"></script>
		<script src="Assets/blochSphere.js"></script>
	</head>
	<body>
		<main>
			<h3 id="Perfect_pairs">Perfect pairs</h3>
			<p>
				A <a href="https://en.wikipedia.org/wiki/Qubit" target="_blank">qubit</a>
				is a pair of <a href="ComplexNumber.html">complex numbers</a>, 
				<span class="symbol">a</span> and <span class="symbol">b</span>,
				such that |<span class="symbol">a</span>|<sup>2</sup> + |<span class="symbol">b</span>|<sup>2</sup> = 1. 
				That is to the say, 
				the absolute value of <span class="symbol">a</span> 
				multiplied by the absolute value of <span class="symbol">a</span>, 
				added to the absolute value of <span class="symbol">b</span> 
				multiplied by absolute value of <span class="symbol">b</span>,
				equals one.
			</p>
			<p>
				Our <span class="symbol">a</span> argument represents our qubit’s “control bit” 
				while our <span class="symbol">b</span> argument 
				represents our qubit’s “target bit”—the part we are ultimately concerned with. 
				A qubit may be in 
				<a href="https://en.wikipedia.org/wiki/Quantum_superposition" target="_blank">superposition</a>, 
				ie. its target bit is neither 0 
				or 1, but somewhere in between.
				The probability that upon measurement the qubit bit will “collapse” to zero is 
				|<span class="symbol">a</span>|<sup>2</sup>, while the 
				probability that the qubit will collapse to one is 
				|<span class="symbol">b</span>|<sup>2</sup>. 
			</p>
			<br>
			<ul>
				<li>A qubit {<span class="symbol">a</span>=1, <span class="symbol">b</span>=0} has a 100% chance of collapsing to 0.</li>
				<li>A qubit {<span class="symbol">a</span>=0, <span class="symbol">b</span>=1} has a 100% chance of collapsing to 1.</li>
				<li>A qubit {<span class="symbol">a</span>=1÷√2, <span class="symbol">b</span>=1÷√2} has a 50% chance of collapsing to 0, and a 50% 
				chance of collapsing to 1.</li>
			</ul>
			<h3 id="Unit_circle">Unit circle</h3>
			<p>
				Given the constraints above, if we plot all of the possible <em>real</em> values for 
				<span class="symbol">a</span>, <span class="symbol">b</span> on a graph 
				as <span class="symbol">x</span> and <span class="symbol">y</span> respectively
				the outcome is a circle with a radius of 1 centered at the origin (0, 0); 
				ie. a <a href="https://en.wikipedia.org/wiki/Unit_circle)" target="_blank">unit circle</a>.
			</p>
<pre><code>
             ( 0, 1 )  Vertical 
                 │
 ( -1÷√2, 1÷√2 ) │ ( 1÷√2, 1÷√2 )  Diagonal
              ╲  │  ╱
               ╲ │ ╱
                ╲│╱ 
( -1, 0 )────────╳────────( 1, 0 )  Horizontal
                ╱│╲
               ╱ │ ╲ 
              ╱  │  ╲
( -1÷√2, -1÷√2 ) │ ( 1÷√2, -1÷√2 )  Anti-diagonal
                 │
                 │
             ( 0, -1 )
</code></pre>

			<h3 id="Bloch_sphere">Bloch sphere</h3>
			<p>
				But a qubit isn’t just a pair of <em>real</em> numbers—it’s a pair of <a href="ComplexNumber.html">complex numbers</a> and plotting those values requires a third dimension.
				This transforms our unit circle in to a
				<a href="https://en.wikipedia.org/wiki/Bloch_sphere" target="_blank">Bloch sphere</a>.
				<!--

				THIS IS A TERRIBLE AND INACCURATE EXPLANATION!
				MUST COME BACK AND RE-WRITE, FOCUS ON THE MATH!

				If you’re familiar with complex numbers you may expect them to add <em>two</em> dimensions to our unit circle rather than one.
				By taking the absolute value of <span class="symbol">a</span> or <span class="symbol">b</span>
				we effectively cancel out this extra dimension.
				-->

				Our unit circle or Bloch Sphere could be used as a state 
				machine for quantum compuation, though 
				<a href="index.html">Q</a> currently focusses on 
				matrices for calculation. 
			</p>
			<br>
			<p id="bloch-sphere-qubits">
				<!-- Select qubit state: <select id="qubit-state-selector"></select><br>-->
			</p>
			<div class="interactive-container" id="bloch-sphere">
				<div class="interactive-component" id="bloch-angles">
					<span class="symbol">a</span> = <span id="bloch-control-bit">—</span><br>
					<span class="symbol">b</span> = <span id="bloch-target-bit">—</span><br>
					<br>
					<span id="bloch-theta">—</span>˚ polar angle ϕ (theta)<br>
					<span id="bloch-phi">—</span>˚ azimuth θ (phi)
				</div>
			</div>
			<p>
				Click and drag the Bloch Sphere to rotate it.
				<em>This visualization method is developing rapidly so expect frequent updates to this Bloch Sphere explorer over the remainder of June and in to July 2019.</em>
			</p>
			<hr>
			<h3 id="Constructor">Constructor</h3>
			<p>
				<code>Q.Qubit</code>
				extends the <code>Q.<a href="Matrix.html">Matrix</a></code> class
				and therefore inherits its class and instance methods.
				When a new qubit is created it internally invokes the
				<code>Q.<a href="Matrix.html">Matrix</a></code> constructor,
				such that <code>new Q.Qubit( <span class="symbol">a</span>, <span class="symbol">b</span> )</code>
				is similar to
				<code>new Q.<a href="Matrix.html">Matrix</a>([ <span class="symbol">a</span> ],[ <span class="symbol">b</span> ])</code>.
				If the two supplied values do not satisfy the assertion that
				|<span class="symbol">a</span>|<sup>2</sup> + |<span class="symbol">b</span>|<sup>2</sup> = 1 
				then an error is thrown.
			</p>
<pre><code>
var a = new Q.Qubit( 0, 1 )
</code></pre>
			<ul class="properties">
				<li>
					<dt id=".this.controlBit"><a href="#.this.controlBit">controlBit</a></dt>
					<dd>Description TK.</dd>
				</li>
				<li>
					<dt id=".this.targetBit"><a href="#.this.targetBit">targetBit</a></dt>
					<dd>Description TK.</dd>
				</li>
				<li>
					<dt id=".this.dirac"><a href="#.this.dirac">dirac</a></dt>
					<dd>Description TK.</dd>
				</li>
				<li>
					<dt id=".this.name"><a href="#.this.name">name</a></dt>
					<dd>Description TK.</dd>
				</li>
				<li>
					<dt id=".this.index"><a href="#.this.index">index</a></dt>
					<dd>
						An auto-incrementing identification number assigned to the instance,
						used for minding the total number of instances created.
					</dd>
				</li>
			</ul>
			<hr>
			<h3 id="Constants">Constants</h3>
			<p>
				While <code>Q.Qubit</code> <a href="#Constants">constants</a>
				are appended directly to the <code>Q.Qubit</code> object,
				they are also appended to a <code>Q.Qubit.constants</code> object
				to make looking up constants in the JavaScript console trivial,
				and to make iterating across all constants convenient via
				functions like 
				<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">Object.entries</a></code>,
				<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">Object.keys</a></code>,
				<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">Object.values</a></code>,
				and so on.
				<code>Q.Qubit</code> provides the following built-in <a href="https://en.wikipedia.org/wiki/Jones_calculus#Jones_vectors" target="_blank">Jones vectors</a>.
			</p>
			<ul class="properties">
				<li>
					<dt id=".HORIZONTAL"><a href="#.HORIZONTAL">HORIZONTAL</a></dt>
					<dd><code>= new Q.Qubit( 1, 0, 'H' )</code></dd>
				</li>
				<li>
					<dt id=".VERTICAL"><a href="#.VERTICAL">VERTICAL</a></dt>
					<dd><code>= new Q.Qubit( 0, 1, 'V' )</code></dd>
				</li>
				<li>
					<dt id=".DIAGONAL"><a href="#.DIAGONAL">DIAGONAL</a></dt>
					<dd><code>= new Q.Qubit( 1÷√2,  1÷√2, 'D' )</code></dd>
				</li>
				<li>
					<dt id=".ANTI_DIAGONAL"><a href="#.ANTI_DIAGONAL">ANTI_DIAGONAL</a></dt>
					<dd><code>= new Q.Qubit( 1÷√2, -1÷√2, 'A' )</code></dd>
				</li>
				<li>
					<dt id=".RIGHT_HAND_CIRCULAR_POLARIZED"><a href="#.RIGHT_HAND_CIRCULAR_POLARIZED">RIGHT_HAND_CIRCULAR_POLARIZED</a></dt>
					<dd><code>= new Q.Qubit( 1÷√2, -1÷√2i, 'R' )</code></dd>
				</li>
				<li>
					<dt id=".LEFT_HAND_CIRCULAR_POLARIZED"><a href="#.LEFT_HAND_CIRCULAR_POLARIZED">LEFT_HAND_CIRCULAR_POLARIZED</a></dt>
					<dd><code>= new Q.Qubit( 1÷√2,  1÷√2i, 'L' )</code></dd>
				</li>
			</ul>
			<hr>
			<h3 id="Static_properties">Static properties</h3>
			<ul class="properties">
				<li>
					<dt id=".index"><a href="#.index">index</a></dt>
					<dd>Description TK</dd>
				</li>
				<li>
					<dt id=".help"><a href="#.help">help</a></dt>
					<dd>Description TK</dd>
				</li>
				<li>
					<dt id=".constants"><a href="#.constants">constants</a></dt>
					<dd>
						While <code>Q.Qubit</code> <a href="#Constants">constants</a>
						are appended directly to the <code>Q.Qubit</code> object,
						they are also appended to a <code>Q.Qubit.constants</code> object
						to make looking up constants in the JavaScript console trivial,
						and to make iterating across all constants convenient via
						functions like 
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">Object.entries</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">Object.keys</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">Object.values</a></code>,
						and so on.
					</dd>
				</li>
				<li>
					<dt id=".createConstant"><a href="#.createConstant">createConstant</a></dt>
					<dd>Description TK</dd>
				</li>
				<li>
					<dt id=".createConstants"><a href="#.createConstants">createConstants</a></dt>
					<dd>Description TK</dd>
				</li>
				<li>
					<dt id=".collapse"><a href="#.collapse">collapse</a></dt>
					<dd>Description TK</dd>
				</li>
				<li>
					<dt id=".toBlochSphere"><a href="#.toBlochSphere">toBlochSphere( qubit )</a></dt>
					<dd>
						Returns the following object for a given qubit’s probability state,
						useful for rendering a <a href="#Bloch_sphere">Bloch Sphere</a> representation.
<pre><code>
{
	theta, <span class="comment">//  Polar angle ϕ.</span>
	phi,   <span class="comment">//  Azimuth θ.</span>

	
	<span class="comment">//  Bloch vector,
	//  the surface point on a Bloch Sphere.</span>

	vector: { x, y, z },

	
	<span class="comment">//  Bloch vector “corrected”
	//  for Y-up coordinate systems.</span>

	position: {

		x: vector.<strong>y</strong>,<span class="comment">//  Note this Y here.</span>
		y: vector.<strong>z</strong>,<span class="comment">//  Note this Z here.</span>
		z: vector.<strong>x</strong> <span class="comment">//  Note this X here.</span>
	}
}
</code></pre>					
					</dd>
				</li>


				<!--

					toBlochSphere
					toXYZ
					fromBlochSphere
					fromXYZ

				-->
			</ul>
			<hr>
			<h3 id="Prototype_properties">Prototype properties</h3>
			<h4>Non-destructive methods</h4>
			<ul class="properties">
				<li>
					<dt id=".prototype.isEqualTo"><a href="#.prototype.isEqualTo">isEqualTo</a></dt>
					<dd>Description TK</dd>
				</li>
				<li>
					<dt id=".prototype.collapse"><a href="#.prototype.collapse">collapse</a></dt>
					<dd>Description TK</dd>
				</li>
			</ul>
			<h4>Destructive methods</h4>
			<ul class="properties">
				<li>
					<dt id=".prototype.copy$"><a href="#.prototype.copy$">copy$</a></dt>
					<dd>Description TK</dd>
				</li>
				<li>
					<dt id=".prototype.collapse$"><a href="#.prototype.collapse$">collapse$</a></dt>
					<dd>Description TK</dd>
				</li>
			</ul>
			<hr>
			Source:
			<a href="https://github.com/stewdio/q.js/blob/master/Q/Qubit.js?ts=4" target="_blank">https://github.com/stewdio/q.js/blob/master/Q/Qubit.js</a>
		</main>
		<script>







/*

	O M F G

	Please forgive the below hideous code
	and interaction that goes with it.
	And the explainer text above that goes with it.
	This is SUCH A WORK IN PROGRESS RIGHT NOW!
	Coming back to fix shortly.

*/




//  First, what do the docs have to say?

//console.log( '\n\nQ.Qubit\n', Q.Qubit.help(), '\n\n' )














//  Create our Bloch Sphere explorer.

const
container = document.getElementById( 'bloch-sphere' ),
fov    = 45,
width  =  container.offsetWidth,
height =  container.offsetHeight,
aspect =  width / height,
near   = 0.1,
far    = 12,
scene  = new THREE.Scene(),
camera = new THREE.PerspectiveCamera( fov, aspect, near, far ),
renderer = new THREE.WebGLRenderer({ 

	// canvas: container,
	alpha: true,
	antialias: true
})

container.appendChild( renderer.domElement )
camera.position.z = 4
renderer.setPixelRatio( window.devicePixelRatio )
renderer.setSize( width, height )
scene.add( camera )


//  We’re going to pull a little trick here...
//  Let’s put our light in the opposite place of where we want it
//  because we’ll render the back face of the sphere
//  so light direction will be inverted.
//  We’ll also attach it to the camera
//  so the light doesn’t appear to move.


const light = new THREE.PointLight( 0xFFFFFF, 0.5, 0 )
light.position.set( -2, 6, 0 )
camera.add( light )
scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.8 ))


//  x

const sphere = new THREE.Group()
scene.add( sphere )


//  Create lines of latitude and longitude.

const grid = createQuadSphere({ radius: 1 })
sphere.add( grid )


//  x

const innards = new THREE.Mesh( 

	new THREE.SphereGeometry( 0.995, 32, 32 ),
	new THREE.MeshPhongMaterial({

		side: THREE.FrontSide,
		color: 0xE6E6E6,
		transparent: true,
		opacity: 0.8
	}) 
)
sphere.add( innards )




const xAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 2.8, 0.01, 0.01 ),
	new THREE.MeshBasicMaterial({ color: 0xFF0000 })
)
sphere.add( xAxis )

const yAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 0.01, 0.01, 2.8 ),
	new THREE.MeshBasicMaterial({ color: 0x0000CC })
)
sphere.add( yAxis )

const zAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 0.01, 2.8, 0.01 ),
	new THREE.MeshBasicMaterial({ color: 0x00CC00 })
)
sphere.add( zAxis )




const 
arrowLength     = 0.101,//  I know, weird, right?
arrowHeadLength = 0.1,
arrowHeadWidth  = 0.1

sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 0, 1.0, 0 ), 
	new THREE.Vector3( 0, 1.4, 0 ), 
	arrowLength, 
	0x00CC00, 
	arrowHeadLength, 
	arrowHeadWidth
))
sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 1.0, 0, 0 ), 
	new THREE.Vector3( 1.4, 0, 0 ), 
	arrowLength, 
	0xFF0000, 
	arrowHeadLength, 
	arrowHeadWidth
))
sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 0, 0, 1.0 ), 
	new THREE.Vector3( 0, 0, 1.4 ),
	arrowLength, 
	0x0000CC, 
	arrowHeadLength, 
	arrowHeadWidth
))




const blochPointer = new THREE.Mesh(

	new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 ),
	new THREE.MeshPhongMaterial({ color: 0x666666 })
)
blochPointer.geometry.translate( 0, -0.5, 0 )
blochPointer.geometry.rotateX( Math.PI / 2 )
blochPointer.geometry.scale( 0.2, 0.2, 0.2 )
blochPointer.lookAt( new THREE.Vector3() )
sphere.add( blochPointer )





const blochVector = new THREE.Mesh(

	new THREE.BoxGeometry( 0.04, 0.04, 1 ),
	new THREE.MeshBasicMaterial({ color: 0x000000 })
)
blochVector.geometry.translate( 0, 0, 0.5 )
sphere.add( blochVector )








const controls = new THREE.OrbitControls( camera, renderer.domElement )
controls.enableZoom = false
controls.enablePan = false



let blochState = Q.Qubit.toBlochSphere( Q.Qubit.HORIZONTAL )
function changeBlochVector( state ){



	if( state === undefined ) state = 'HORIZONTAL'
	if( typeof state === 'string' ) state = Q.Qubit[ state ]
	//else assume state is an instance of Qubit!

	const blochStateNext = Q.Qubit.toBlochSphere( state )


	//document.getElementById( 'qubit-state-matrix' ).innerText = state.toTsv()
	document.getElementById( 'bloch-control-bit' ).innerText = state.controlBit.toString()
	document.getElementById( 'bloch-target-bit' ).innerText = state.targetBit.toString()
	


	const blochSphereQubits = document.getElementById( 'bloch-sphere-qubits' )
	Array.from( blochSphereQubits.children ).forEach( function( child ){

		if( child.getAttribute( 'data-qubit' ) === state.name ) child.classList.add( 'selected' )
		else child.classList.remove( 'selected' )
	})



	window.tween = new TWEEN.Tween({

			theta: blochState.theta,
			phi: blochState.phi
		
		})//  Yes, this will be destructive to the blochState object.
		.to({

			theta: blochStateNext.theta,
			phi: blochStateNext.phi
		
		}, 1000 )
		.easing( TWEEN.Easing.Quadratic.InOut )
		.onUpdate( updateBlochVector )
		.start()
}




function updateBlochVector( blochStateNow ){


	blochState.theta = blochStateNow.theta
	blochState.phi = blochStateNow.phi




	//  Move the big-ass surface pointer.

	blochPointer.position.set(
		
		Math.sin( blochState.theta ) * Math.sin( blochState.phi ),
		Math.cos( blochState.theta ),
		Math.sin( blochState.theta ) * Math.cos( blochState.phi )
	)
	blochPointer.lookAt( new THREE.Vector3() )


	blochVector.lookAt( blochPointer.getWorldPosition( new THREE.Vector3() ))


	//  Update our angles labels.
	
	document.getElementById( 'bloch-theta' ).innerText = ( blochState.theta * Q.RADIANS_TO_DEGREES ).toFixed()
	document.getElementById( 'bloch-phi' ).innerText = ( blochState.phi * Q.RADIANS_TO_DEGREES ).toFixed()


	



	/*
	const
	radius = 1,
	arcR = radius * Math.sin( bloch.theta ),
	arcH = radius * Math.cos( bloch.theta ),
	thetaGeometry = createLatitudeArc( arcR, 64, Math.PI / 2, Math.PI * 2 )

	thetaGeometry.rotateX( Math.PI / 2 )
	thetaGeometry.rotateY( Math.PI / 2 )
	thetaGeometry.translate( 0, arcH, 0 )
	sphere.add( new THREE.Line( 

		thetaGeometry,
		new THREE.LineBasicMaterial({ color: 0x000000 })
	))



	const
	arc = createLongitudeArc( radius, 64, Math.PI / -2, Math.PI )
	phiGeometry = arc.clone()
	
	phiGeometry.rotateY( bloch.phi )
	sphere.add( new THREE.Line( 

		phiGeometry,
		new THREE.LineBasicMaterial({ color: 0x000000 })
	))
	*/


	// blochVector.lookAt( blochCorrected )

	// mesh.position.copy( blochCorrected.clone().multiplyScalar( 10.1 + size / 2 ))

	//blochVectorLine.geometry.vertices[ 1 ].copy( blochCorrected.clone().multiplyScalar( 10.1 ))
	
	// const a = blochCorrected.clone()//.multiplyScalar( 10.1 )
	// blochVectorLine.geometry.setPositions([ 
	
	// 	0,  0, 0,  
	// 	a.x, a.y, a.z
	// ])
}








sphere.rotation.x = 0.7
sphere.rotation.z = 0.2



const render = function(){

	requestAnimationFrame( render )
	controls.update()
	sphere.rotation.y += 0.0009;
	renderer.render( scene, camera )
	TWEEN.update()
}

window.addEventListener( 'resize', function () {

	const
	width  = container.offsetWidth,
	height = container.offsetHeight
	
	camera.aspect = width / height
	camera.updateProjectionMatrix()
	renderer.setSize( width, height )

}, false )

render()










const blochSphereQubits = document.getElementById( 'bloch-sphere-qubits' )

Object.keys( Q.Qubit.constants ).forEach( function( key ){

	

	const 
	qubit = Q.Qubit[ key ],
	qubitContainerElement = document.createElement( 'div' )
	qubitElement = document.createElement( 'div' )
	qubitNameElement = document.createElement( 'p' )
	
	qubitContainerElement.classList.add( 'qubit-container' )
	qubitContainerElement.setAttribute( 'data-qubit',  qubit.name )


	qubitElement.classList.add( 'qubit' )
	qubitElement.setAttribute( 'title', Q.toTitleCase( qubit.name ))
	qubitElement.innerText = qubit.dirac
	qubitElement.addEventListener( 'click', function(){

		changeBlochVector( qubit )
	})
	qubitContainerElement.appendChild( qubitElement )

	// qubitNameElement.innerText = Q.toTitleCase( qubit.name )
	// qubitContainerElement.appendChild( qubitNameElement )
	
	blochSphereQubits.appendChild( qubitContainerElement )
})






changeBlochVector()





		</script>
	</body>
</html>