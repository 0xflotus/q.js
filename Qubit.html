<!DOCTYPE html>
<html>
	<head>
		<title>Q ⟩ Qubit</title>
		<meta charset="utf-8">
		<meta name="viewport"             content="width=device-width,initial-scale=1.0">
		<meta name="description"          content="Q.js is quantum computing in your browser.">
		<meta name="copyright"            content="Stewart Smith 2019">
		<meta name="keywords"             content="
			Q, Q.js, Qjs,
			quantum, quantum physics, quantum mechanics, superposition,
			quantum computer, quantum computer programming, quantum computing, QC, 
			quantum simulator, quantum computer simulator, 
			qubit, qbit, gate, Hadamard, Bloch, Bloch Sphere,
			Web, Web site, website, Web browser, browser, HTML, HTML5, JavaScript, ES6, CSS,
			Chrome, Firefox, Safari, Opera, Brave, Edge, WebKit, Blink,
			Stewart Smith, Stewart, Stew, Stuart, Steven, Steve, Stewdio, stew_rtsmith, @stew_rtsmith,
			Moar, Moar Technologies Corp, MTC,
			Google, IBM, Microsoft, NASA, DWave, D-Wave,
			Quil, OpenQASM,
				ProjectQ, Qiskit, 
				Quantum Development Kit, Cirq, Strawberry Fields, t|ket>,
				QCL, Quantum pseudocode, Q#, Q|SI>, Q language, qGCL, QFC, QML, LIQUi|>, Quipper,
			Stanford CS 269 Q: Quantum Computer Programming">
		
		<meta name="twitter:card"         content="summary">
		<meta name="twitter:site"         content="@stew_rtsmith">
		<meta name="twitter:creator"      content="@stew_rtsmith">
		<meta name="twitter:title"        content="Q ⟩ Qubit">
		<meta name="twitter:description"  content="Quantum computing in your browser.">
		<meta name="twitter:image"        content="https://stewdio.github.io/q.js/Assets/q-thumbnail.png">
		
		<meta property="og:type"          content="website">
		<meta property="og:title"         content="Q ⟩ Qubit">
		<meta property="og:description"   content="Quantum computing in your browser.">
		<meta property="og:image"         content="https://stewdio.github.io/q.js/Assets/q-thumbnail.png">
		<meta property="og:url"           content="https://stewdio.github.io/q.js/Qubit.html">
		
		<link rel="canonical"             href="https://stewdio.github.io/q.js/Qubit.html">
		<link rel="icon" type="image/png" href="Assets/q-favicon-064.png">
		<link rel="apple-touch-icon"      href="Assets/q-favicon-144.png">
		<link rel="stylesheet" type="text/css" href="Assets/style.css">
		
		<script async src="https://www.googletagmanager.com/gtag/js"></script>
		<script src="Assets/ga.js"></script>
		<script src="Q/Q.js"></script>
		<script src="Q/ComplexNumber.js"></script>
		<script src="Q/Matrix.js"></script>
		<script src="Q/Qubit.js"></script>
		<script src="Q/Gate.js"></script>
		<script src="Q/Circuit.js"></script>
		<script src="Assets/navigation.js"></script>
		<script src="Assets/Three/three.105.min.js"></script>
		<script src="Assets/Three/OrbitControls.js"></script>
		<script src="Assets/Tween/tween.min.js"></script>
		<script src="Assets/blochSphere.js"></script>
		<script src="Assets/SurfaceText.js"></script>
	</head>
	<body>
		<main>
			<h3>Perfect pairs</h3>
			<p>
				A <a href="https://en.wikipedia.org/wiki/Qubit" target="_blank">qubit</a>
				is just a pair of numbers.
				That’s all they are—two 
				<a href="https://youtu.be/YYOKMUTTDdA" target="_blank">shiny happy number values,
				holding hands</a>.
				Traditionally, we use 
				“<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">bra-ket terminology</a>”
				to refer to these two numbers—calling
				the first number 
				“<code><a href="Qubit.html#this.bra">bra</a></code>” 
				and the second one 
				“<code><a href="Qubit.html#this.ket">ket</a></code>.”
				(I know that sounds a little childish and stupid, but then so is high school.)
				So when you think of a qubit you can imagine it as 
				a 1 × 2 <a href="Matrix.html">matrix</a>
				containing a 
				<code><a href="Qubit.html#this.bra">bra</a></code> value on the top
				and a 
				<code><a href="Qubit.html#this.ket">ket</a></code> value on the bottom,
				like so:
			</p>
			<div class="center">
				<div class="matrix">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>bra</td></tr>
						<tr><td>ket</td></tr>
					</table>
				</div>
			</div>
			<br>
			<p>
				Because these two numbers 
				share a predictable relationship with each other,
				if we know the value of one number 
				then we have a pretty good idea what the value of the other is.
				If you know the 
				<code><a href="Qubit.html#this.bra">bra</a></code>
				you know the 
				<code><a href="Qubit.html#this.ket">ket</a></code>.
				(Or nearly so.)
				For this reason, when we discuss the value of a qubit
				we often only refer to one of these values instead of both.
				By convention the value we choose to represent a qubit
				is its 
				<code><a href="Qubit.html#this.ket">ket</a></code> value.
				So when we say “this qubit has a value of zero”
				what we’re really saying is that its 
				<code><a href="Qubit.html#this.ket">ket</a></code> value is <code>0</code>:
			</p>
			<div class="center maths">
				“zero” =
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>bra: 1</td></tr>
						<tr><td>ket: 0</td></tr>
					</table>
				</div>
			</div>
			<br>
			<p>
				Conversely, when we say “this qubit has a value of one”
				we’re claiming that its 
				<code><a href="Qubit.html#this.ket">ket</a></code> value is <code>1</code>:
			</p>
			<div class="center maths">
				“one” =
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>bra: 0</td></tr>
						<tr><td>ket: 1</td></tr>
					</table>
				</div>
			</div>
			<br>
			<h4>Bra-ket notation</h4>
			<p>
				<a href="https://en.wikipedia.org/wiki/Paul_Dirac" target="_blank">Paul Dirac</a>’s 
				<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">bra-ket notation</a>
				offers us a more compact (and quantum-specific)
				means of describing qubit states.
				Let’s look again at the 
				<a href="Matrix.html">matrix</a> form
				for a qubit in a “zero” state:
			</p>
			<div class="center maths">
				<div class="matrix qubit">
					<div class="matrix-bracket-left"></div>
					<div class="matrix-bracket-right"></div>
					<table>
						<tr><td>1</td></tr>
						<tr><td>0</td></tr>
					</table>
				</div>
			</div>
			<br>
			<p>
				With <a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">bra-ket notation</a>
				we can rewrite the 
				<a href="Matrix.html">matrix</a>
				in <a href="https://en.wikipedia.org/wiki/Row_and_column_vectors" target="_blank">vector form</a> like so:
				<span class="complex-vector bra">1</span>
				<span class="complex-vector ket">0</span>
				And because we generally only need one of the two
				<code><a href="Qubit.html#this.bra">bra</a></code> / 
				<code><a href="Qubit.html#this.ket">ket</a></code> pairs,
				we can conveniently separate them in to
				<span class="complex-vector bra">1</span>
				<span>and</span>
				<span class="complex-vector ket">0</span>.
				So now when we refer to a “zero” qubit we can represent that as
				<span class="complex-vector ket">0</span>,
				and a “one” qubit as 
				<span class="complex-vector ket">1</span>.
			</p>
			<h3 id="Predictable_couple">A predictable couple</h3>
			<p>
				The thing that makes this pair of numbers special
				is their relationship to each other.
				We can express this relationship as
				|<code><a href="Qubit.html#this.bra">bra</a></code>|<sup>2</sup> + 
				|<code><a href="Qubit.html#this.ket">ket</a></code>|<sup>2</sup> = 1. 
				That is to the say, 
				the absolute value of
				<code><a href="Qubit.html#this.bra">bra</a></code>
				multiplied by the absolute value of 
				<code><a href="Qubit.html#this.bra">bra</a></code>, 
				added to the absolute value of 
				<code><a href="Qubit.html#this.ket">ket</a></code>
				multiplied by the absolute value of 
				<code><a href="Qubit.html#this.ket">ket</a></code>,
				equals one.
				This is what defines a qubit.
				If a pair of numbers does <em>not</em> satisfy this equation
				then it is not a qubit. (Sorry.)
			</p>
			<p>
				Keen mathematical minds might be asking
				why we must take the absolute value of a number
				before squaring it.
				Doesn’t multiplying a number by itself automatically yield an absolute value?
				Oh, dear readers…
				Things are about to get more <em>complex</em>.
			</p>
			<h4 id="Complex_couple">But also a complex couple</h4>
			<p>
				So far we’ve described qubits as containing
				<code><a href="Qubit.html#this.bra">bra</a></code>
				and 
				<code><a href="Qubit.html#this.ket">ket</a></code>
				values ranging from <code>0</code> to <code>1</code>,
				and that remains true—but there’s more to the story.
				Qubits are actually made of 
				<a href="ComplexNumber.html">complex number</a> pairs,
				meaning there is an <em>imaginary component.</em>
				So <em>one</em> qubit is actually made of <em>four</em> parts:
				The <code><a href="Qubit.html#this.bra">bra</a></code>
				has a ① <code><a href="ComplexNumber.html#this.real">real</a></code>
				component and an ②
				<code><a href="ComplexNumber.html#this.imaginary">imaginary</a></code>
				one.
				The <code><a href="Qubit.html#this.ket">ket</a></code>
				also has a ③ <code><a href="ComplexNumber.html#this.real">real</a></code>
				component and an ④
				<code><a href="ComplexNumber.html#this.imaginary">imaginary</a></code>
				one.
				(See <code><a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a></code> for more details.)
				This makes 
				<a href="Qubit.html#Visualizing_qubit_states">visualizing qubit states</a> all the more interesting.
			</p>

			<h3>Superposition</h3>
			<p>
				You’ve probably heard the term 
				“<a href="https://en.wikipedia.org/wiki/Quantum_superposition" target="_blank">superposition</a>”—and along with that 
				you’ve likely been spoonfed some measure of mysticism; 
				<a href="https://youtu.be/CMdHDHEuOUE">pizza-bagels</a> and whatnot.
				In the real, physical world, superposition is indeed weird magic.
				But in quantum computing it’s dead simple.
				Superposition is any qubit state other than
				<span class="complex-vector ket">0</span>
				or
				<span class="complex-vector ket">1</span>.
				That’s it.
				That’s all there is to it.
			</p>
			<p>
				What the 
				<code><a href="Qubit.html#this.bra">bra</a></code>
				and 
				<code><a href="Qubit.html#this.ket">ket</a></code>
				values represent are the probabilities that a qubit,
				when measured, will be in either a
				<span class="complex-vector ket">0</span>
				or a
				<span class="complex-vector ket">1</span>
				state.
				Measurement itself causes a qubit’s
				<a href="https://en.wikipedia.org/wiki/Wave_function_collapse"  target="_blank">probability wave to collapse</a>,
				brining an end to its superposition.
				The probabilty that upon measurement a qubit will 
				<a href="#.prototype.collapse">collapse</a> to 
				<span class="complex-vector ket">0</span>
				is |<code><a href="Qubit.html#this.bra">bra</a></code>|<sup>2</sup>,
				while the probabilty that it will 
				<a href="#.prototype.collapse">collapse</a> to 
				<span class="complex-vector ket">1</span>
				is |<code><a href="Qubit.html#this.ket">ket</a></code>|<sup>2</sup>.
			</p>
			<br>
			<ul>
				<li>
					A qubit, <code>{
						<a href="Qubit.html#this.bra">bra</a>: 1,
						<a href="Qubit.html#this.bra">ket</a>: 0
					}</code>, has a 100% chance of collapsing to <span class="complex-vector ket">0</span>.
				</li>
				<li>
					A qubit, <code>{
						<a href="Qubit.html#this.bra">bra</a>: 0,
						<a href="Qubit.html#this.bra">ket</a>: 1
					}</code>, has a 100% chance of collapsing to <span class="complex-vector ket">1</span>.
				</li>
				<li>
					A qubit, <code>{
						<a href="Qubit.html#this.bra">bra</a>: 1÷√2,
						<a href="Qubit.html#this.bra">ket</a>: 1÷√2
					}</code>, 
					has a 50% chance of collapsing to <span class="complex-vector ket">0</span>
					and a 50% chance of collapsing to <span class="complex-vector ket">1</span>.
				</li>
			</ul>
			<br>
			<h3>Visualizing qubit states</h3>
			<p>
				Given the constraints above, if we plot all of the possible <em>real</em> values for 
				<span class="symbol">a</span>, <span class="symbol">b</span> on a graph 
				as <span class="symbol">x</span> and <span class="symbol">y</span> respectively
				the outcome is a circle with a radius of 1 centered at the origin (0, 0); 
				ie. a <a href="https://en.wikipedia.org/wiki/Unit_circle)" target="_blank">unit circle</a>.
			</p>
			<div class="unit-circle">
				<div class="unit-circle-outline"></div>
				<div class="unit-circle-spoke unit-circle-spoke-0"></div>
				<div class="unit-circle-spoke unit-circle-spoke-45"></div>
				<div class="unit-circle-spoke unit-circle-spoke-90"></div>
				<div class="unit-circle-spoke unit-circle-spoke-135"></div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-90">Vertical</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-45">Diagonal</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-0">Horizontal</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-315">Anti-diagonal</div>
				<div class="unit-circle-label unit-circle-label-angle-0">0˚</div>
				<div class="unit-circle-label unit-circle-label-angle-45">45˚</div>
				<div class="unit-circle-label unit-circle-label-angle-90">90˚</div>
				<div class="unit-circle-label unit-circle-label-angle-135">135˚</div>
				<div class="unit-circle-label unit-circle-label-angle-180">180˚</div>
				<div class="unit-circle-label unit-circle-label-angle-225">225˚</div>
				<div class="unit-circle-label unit-circle-label-angle-270">270˚</div>
				<div class="unit-circle-label unit-circle-label-angle-315">315˚</div>
				<div class="unit-circle-label unit-circle-label-point-0">1, 0</div>
				<div class="unit-circle-label unit-circle-label-point-45">
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-90">0, 1</div>
				<div class="unit-circle-label unit-circle-label-point-135">
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-180">-1, 0</div>
				<div class="unit-circle-label unit-circle-label-point-225">
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-270">0, -1</div>
				<div class="unit-circle-label unit-circle-label-point-315">
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
			</div>
			<h4 id="Bloch_sphere">The Bloch sphere</h4>
			<p>
				But a qubit isn’t just a pair of <em>real</em> numbers—it’s a pair of <a href="ComplexNumber.html">complex numbers</a> and plotting those values requires a third dimension.
				This transforms our unit circle in to a
				<a href="https://en.wikipedia.org/wiki/Bloch_sphere" target="_blank">Bloch sphere</a>.
				<!--

				THIS IS A TERRIBLE AND INACCURATE EXPLANATION!
				MUST COME BACK AND RE-WRITE, FOCUS ON THE MATH!

				If you’re familiar with complex numbers you may expect them to add <em>two</em> dimensions to our unit circle rather than one.
				By taking the absolute value of <span class="symbol">a</span> or <span class="symbol">b</span>
				we effectively cancel out this extra dimension.
				-->

				Our unit circle or Bloch Sphere could be used as a state 
				machine for quantum compuation, though 
				<a href="Q.html">Q</a> currently focusses on 
				matrices for calculation. 
			</p>
			<br>
			<p>
				Select a qubit state:
			</p>
			<div id="bloch-sphere-qubits"></div>
			<p>
				Select a gate to apply:
			</p>
			<div id="bloch-sphere-gates"></div>
			<div class="interactive-container" id="bloch-sphere">
				<div class="interactive-component" id="bloch-angles">
					<span class="symbol">a</span> = <span id="bloch-bra">—</span><br>
					<span class="symbol">b</span> = <span id="bloch-ket">—</span><br>
					<br>
					<span id="bloch-theta">—</span>˚ polar angle θ (theta)<br>
					<span id="bloch-phi">—</span>˚ azimuth angle ϕ (phi)
				</div>
			</div>
			<p>
				Click and drag the Bloch Sphere to rotate it.
			</p>
			<hr>
			<h3>Constructor</h3>
			<p>
				<code>Qubit</code>
				extends the <code><a href="Matrix.html">Matrix</a></code> class
				and therefore inherits its static and prototypal properties.
				The constructor expects two arguments that are each either
				instances of <code>Number</code> or <code><a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a></code>.
				An optional third argument, expected in the form of a single character <code>String</code>, may be used as a text label for the qubit.
				If no text label is provided the constructor checks against the list of existing 
				<code><a href="#.constants">constants</a></code>
				and if a match is found then that label is applied to this instance.
			</p>
			<p>
				When a new qubit is created it internally invokes the
				<code><a href="Q.html">Q</a>.<a href="Matrix.html">Matrix</a></code> constructor,
				such that <code>new <a href="Q.html">Q</a>.Qubit( <span class="symbol">a</span>, <span class="symbol">b</span> )</code>
				is similar to
				<code>new <a href="Q.html">Q</a>.<a href="Matrix.html">Matrix</a>([ <span class="symbol">a</span> ],[ <span class="symbol">b</span> ])</code>.
				If the two supplied values do not satisfy the assertion that
				|<span class="symbol">a</span>|<sup>2</sup> + |<span class="symbol">b</span>|<sup>2</sup> = 1 
				then an error is thrown.
			</p>
<pre><code>
var a = new <a href="Q.html">Q</a>.Qubit( 0, 1 )
</code></pre>
			<ul class="properties">
				<li>
					<dt id="this.bra">bra</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a></code>
						The <span class="symbol">a</span> or 
						<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">bra</a> component of the qubit state.
					</dd>
				</li>
				<li>
					<dt id="this.ket">ket</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a></code>
						The <span class="symbol">b</span> or 
						<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">ket</a> component of the qubit state.
					</dd>
				</li>
				<li>
					<dt id="this.label">label</dt>
					<dd>
						<code class="value-type">String</code>
						Single character representing this qubit state, 
						for example ‘H’ for <a href="#.HORIZONTAL">horizontal</a>. 
						This can be passed to the constructor as an optional third argument 
						or automatically assigned based on existing <code><a href="Q.html">Q</a>.Qubit.<a href="#.constants">constants</a></code>
						If no match is found among existings constants the ‘?’ character is assigned.
						Note: This property name and behavior expected to change in the near future.
					</dd>
				</li>
				<li>
					<dt id="this.name">name</dt>
					<dd>
						<code class="value-type">String</code>
						The name of the qubit state, assigned based on existing <code>Q.Qubit.<a href="#.constants">constants</a></code>.
						If no match is found among existings constants the name is left empty.
						Note: This property name and behavior expected to change in the near future.
					</dd>
				</li>
				<li>
					<dt id="this.index">index</dt>
					<dd>
						<code class="value-type">Number</code>
						An identification number assigned to the instance based on the
						auto-incrementing static number <code><a href="Q.html">Q</a>.Qubit.<a href="#.index">index</a></code>.
						Used for minding the total number of instances created.
					</dd>
				</li>
			</ul>
			<hr>
			<h3>Static properties</h3>
			<p>
				Because <code>Q.Qubit</code> extends <code>Q.<a href="Matrix.html">Matrix</a></code>,
				the following append or replace the latter’s existing static properties.
			</p>
			<ul class="properties">
				<li>
					<dt id=".help">help</dt>
					<dd>
						<code class="value-type">Function ⇒ String</code>
						Calls and returns the value of 
						<code><a href="Q.html">Q</a>.<a href="#.help">help</a></code>,
						passing <code><a href="Q.html">Q</a>.Qubit</code> as the argument.
					</dd>
				</li>
				<li>
					<dt id=".index">index</dt>
					<dd>
						<code class="value-type">Number</code>
						The number of instances created so far.
					</dd>
				</li>
			</ul>
			<h4>Constants and constant creation</h4>
			<ul class="properties">
				<li>
					<dt id=".constants">constants</dt>
					<dd>
						<code class="value-type">Object</code>
						Constants are appended <em>directly</em> to the 
						<code><a href="Q.html">Q</a>.Qubit</code> object.
						For convenience they are also appended to this
						<code><a href="Q.html">Q</a>.Qubit</code>.constants</code> object
						to make looking up constants in the JavaScript console trivial,
						and to make iterating across all constants convenient via functions like 
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">Object.entries</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">Object.keys</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">Object.values</a></code>,
						and so on.
						<!-- Configured to be unwritable once appended via
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">Object.defineProperty</a></code>
						and they are labeled in uppercase to signal to us that this is so. -->
						The intention that a property act as a constant is signaled 
						by its labelling in all-uppercase.
					</dd>
				</li>
				<li>
					<dt id=".createConstant">createConstant</dt>
					<dd>
						<code class="value-type">Function( key: String, value: * )<!-- → undefined --></code>
						Appends a property named by <code>key</code> 
						with a value of <code>value</code>
						to both the 
						<code>Q</code> object 
						and its <code><a href="#.constants">constants</a></code> property.
					</dd>
				</li>
				<li>
					<dt id=".createConstants">createConstants</dt>
					<dd>
						<code class="value-type">Function( … )</code>
						Expects an even number of arguments.
						Will use each pair in the sequence of arguments to call
						<code><a href="#.createConstant">createConstant</a></code>.
					</dd>
				</li>
			</ul>
			<h4 id="Jones_Vectors">Constants — Jones Vectors</h4>
			<p>
				<code><a href="Q.html">Q</a>.Qubit</code> provides the following built-in <a href="https://en.wikipedia.org/wiki/Jones_calculus#Jones_vectors" target="_blank">Jones vectors</a>.
			</p>
			<ul class="properties">
				<li>
					<dt id=".HORIZONTAL">HORIZONTAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( 1, 0, 'H', 'Horizontal' )</code>.
						Commonly thought of as “zero” or “off.”
						Described by the following matrix:<br>
						<div class="matrix qubit">
							<div class="matrix-bracket-left"></div>
							<div class="matrix-bracket-right"></div>
							<table>
								<tr><td>1</td></tr>
								<tr><td>0</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".VERTICAL">VERTICAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( 0, 1, 'V', 'Vertical' )</code>.
						Commonly thought of as “one” or “on.”
						Described by the following matrix:<br>
						<div class="matrix qubit">
							<div class="matrix-bracket-left"></div>
							<div class="matrix-bracket-right"></div>
							<table>
								<tr><td>0</td></tr>
								<tr><td>1</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".DIAGONAL">DIAGONAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, Math.SQRT1_2, 'D', 'Diagonal' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>1</td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".ANTI_DIAGONAL">ANTI_DIAGONAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, -Math.SQRT1_2, 'A', 'Anti-diagonal' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>-1</td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".RIGHT_HAND_CIRCULAR_POLARIZED">RIGHT_HAND_CIRCULAR_POLARIZED</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, new <a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a>( 0, -Math.SQRT1_2 ), 'R', 'Right-hand Circular Polarized' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>-<span class="symbol">i</span></td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".LEFT_HAND_CIRCULAR_POLARIZED">LEFT_HAND_CIRCULAR_POLARIZED</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, new <a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a>( 0, Math.SQRT1_2 ), 'L', 'Left-hand Circular Polarized' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td><span class="symbol">i</span></td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
			</ul>
			<h4>Self inspection</h4>
			<ul class="properties">
				<li>
					<dt id=".collapse">collapse</dt>
					<dd>
						<code class="value-type">Function ⇒ <a href="Q.html">Q</a>.Qubit</code>
						Expects a single <code>Q.Qubit</code> instance as argument.
						Returns a new <code>Q.Qubit</code> randomly chosen to be either
						<code>new Qubit( 1, 0 )</code> (<code><a href="#.HORIZONTAL">HORIZONTAL</a></code>)
						 or
						 <code>new Qubit( 0, 1 )</code> (<code><a href="#.VERTICAL">VERTICAL</a></code>)
						 based on the probability of the supplied qubit argument.
					</dd>
				</li>
				<li>
					<dt id=".areEqual">areEqual</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects two instances of <code>Q.Qubit</code> as arguments.
						If the <code><a href="#.bra">bra</a></code> of each are within 
						<code>Q.<a href="Q.html#.EPSILON">EPSILON</a></code>
						and the <code><a href="#.ket">ket</code></a> of each are within 
						<code>Q.<a href="Q.html#.EPSILON">EPSILON</a></code>
						then returns <code>true</code>, otherwise <code>false</code>.
					</dd>
				</li>
				<li>
					<dt id=".toBlochSphere">toBlochSphere</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects a single <code>Q.Qubit</code> instance as argument.
						Returns the following object for a given qubit’s probability state,
						useful for rendering a <a href="#Bloch_sphere">Bloch Sphere</a> representation.
<pre><code>
{
	theta, <span class="comment">//  Polar angle θ.</span>
	phi,   <span class="comment">//  Azimuth angle ϕ.</span>

	
	<span class="comment">//  Bloch vector,
	//  the surface point on a Bloch Sphere.</span>

	vector: { x, y, z },

	
	<span class="comment">//  Bloch vector “corrected”
	//  for Y-up coordinate systems.</span>

	position: {

		x: vector.<strong>y</strong>,<span class="comment">//  Note this Y here.</span>
		y: vector.<strong>z</strong>,<span class="comment">//  Note this Z here.</span>
		z: vector.<strong>x</strong> <span class="comment">//  Note this X here.</span>
	}
}
</code></pre>					
					</dd>
				</li>


				<!--

					toBlochSphere
					toXYZ
					fromBlochSphere
					fromXYZ

				-->
			</ul>
			<hr>
			<h3>Prototype properties</h3>
			<p>
				Because <code>Q.Qubit</code> extends <code>Q.<a href="Matrix.html">Matrix</a></code>,
				the following append or replace the latter’s existing prototype properties.
			</p>
			<h4>Non-destructive methods</h4>
			<ul class="properties">
				<li>
					<dt id=".prototype.isEqualTo">isEqualTo</dt>
					<dd>
						<code class="value-type">Function</code>
						Calls and returns the result of static method 
						<code>Q.Qubit.<a href="#.areEqual">areEqual</a>( this, otherQubit )</code>.
						The returned <code>Boolean</code> breaks method chaining.
					</dd>
				</li>
				<li>
					<dt id=".prototype.collapse">collapse</dt>
					<dd>
						<code class="value-type">Function</code>
						Calls and returns the result of static method 
						<code>Q.Qubit.<a href="#.collapse">collapse</a>( this )</code>.
					</dd>
				</li>
				<li>
					<dt id=".prototype.toBlochSphere">toBlochSphere</dt>
					<dd>
						<code class="value-type">Function</code>
						Calls and returns the result of static method 
						<code>Q.Qubit.<a href="#.toBlochSphere">toBlochSphere</a>( this )</code>.
						The returned <code>Object</code> breaks method chaining.
					</dd>
				</li>
			</ul>
			<h4>Destructive methods</h4>
			<ul class="properties">
				<li>
					<dt id=".prototype.copy$">copy$</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects a single <code>Q.Qubit</code> instance as argument.
						Overwrites the internal <code>bra</code>
						and <code>ket</code> values
						with those of the supplied <code>Q.Qubit</code> instance argument.
					</dd>
				</li>
				<li>
					<dt id=".prototype.collapse$">collapse$</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects no arguments.
						Calls the non-destructive <code><a href="#.prototype.collapse">collapse</a></code> method,
						then uses <code><a href="#.prototype.copy$">copy$</a></code> to overwrite
						this qubit’s values.
					</dd>
				</li>
			</ul>
			<hr>
			<footer>
				<p>
					Source:
					<a href="https://github.com/stewdio/q.js/blob/master/Q/Qubit.js?ts=4" target="_blank">https://github.com/stewdio/q.js/blob/master/Q/Qubit.js</a>
				</p>
			</footer>
		</main>
		<script>


//  First, what do the docs have to say?

// console.log( '\n\nQ.Qubit\n\n', Q.Qubit.help(), '\n\n' )





/*

	O M F G

	Please forgive the below hideous code
	and interaction that goes with it.
	And the explainer text above that goes with it.
	This is SUCH A WORK IN PROGRESS RIGHT NOW!
	Coming back to fix shortly.

*/




//  First, what do the docs have to say?

//console.log( '\n\nQ.Qubit\n', Q.Qubit.help(), '\n\n' )













//  Create our Bloch Sphere explorer.

const
container = document.getElementById( 'bloch-sphere' ),
fov    = 45,
width  =  container.offsetWidth,
height =  container.offsetHeight,
aspect =  width / height,
near   = 0.1,
far    = 12,
scene  = new THREE.Scene(),
camera = new THREE.PerspectiveCamera( fov, aspect, near, far ),
renderer = new THREE.WebGLRenderer({ 

	// canvas: container,
	alpha: true,
	antialias: true
})

container.appendChild( renderer.domElement )
camera.position.z = 4
renderer.setPixelRatio( window.devicePixelRatio )
renderer.setSize( width, height )
scene.add( camera )


//  We’re going to pull a little trick here...
//  Let’s put our light in the opposite place of where we want it
//  because we’ll render the back face of the sphere
//  so light direction will be inverted.
//  We’ll also attach it to the camera
//  so the light doesn’t appear to move.


const light = new THREE.PointLight( 0xFFFFFF, 0.5, 0 )
light.position.set( -2, 6, 0 )
camera.add( light )
scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.8 ))


//  x

const sphere = new THREE.Group()
scene.add( sphere )


//  Create lines of latitude and longitude.

const grid = createQuadSphere({ radius: 1 })
sphere.add( grid )


//  x

const innards = new THREE.Mesh( 

	new THREE.SphereGeometry( 0.995, 32, 32 ),
	new THREE.MeshPhongMaterial({

		side: THREE.FrontSide,
		color: 0xE6E6E6,
		transparent: true,
		opacity: 0.8
	}) 
)
sphere.add( innards )




const yAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 2.5, 0.01, 0.01 ),
	new THREE.MeshBasicMaterial({ color: 0x33BB77 })
)
sphere.add( yAxis )

const xAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 0.01, 0.01, 2.5 ),
	new THREE.MeshBasicMaterial({ color: 0xFF4433 })
)
sphere.add( xAxis )

const zAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 0.01, 2.5, 0.01 ),
	new THREE.MeshBasicMaterial({ color: 0x0366D6 })
)
sphere.add( zAxis )





const 
arrowLength     = 0.101,//  I know, weird, right?
arrowHeadLength = 0.1,
arrowHeadWidth  = 0.1

sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 0, 1.0, 0 ), 
	new THREE.Vector3( 0, 1.25, 0 ), 
	arrowLength, 
	0x0366D6, 
	arrowHeadLength, 
	arrowHeadWidth
))
sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 1.0, 0, 0 ), 
	new THREE.Vector3( 1.25, 0, 0 ), 
	arrowLength, 
	0x33BB77, 
	arrowHeadLength, 
	arrowHeadWidth
))
sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 0, 0, 1.0 ), 
	new THREE.Vector3( 0, 0, 1.25 ),
	arrowLength, 
	0xFF4433, 
	arrowHeadLength, 
	arrowHeadWidth
))





const axesLabelStyle = {

	width:   128,
	height:  128,
	fillStyle: '#000',
	font: 'bold italic 64px Georgia, "Times New Roman", serif'
}
const xAxisLabel = new SurfaceText( axesLabelStyle )
xAxisLabel.print( 'x' )
xAxisLabel.position.set( 0, 0, 1.45 )
xAxisLabel.scale.set( 0.002, 0.002, 0.002 )
xAxis.add( xAxisLabel )

const yAxisLabel = new SurfaceText( axesLabelStyle )
yAxisLabel.print( 'y' )
yAxisLabel.position.set( 1.45, 0, 0 )
yAxisLabel.scale.set( 0.002, 0.002, 0.002 )
yAxis.add( yAxisLabel )


const zAxisLabel = new SurfaceText( axesLabelStyle )
zAxisLabel.print( 'z' )
zAxisLabel.position.set( 0, 1.45, 0 )
zAxisLabel.scale.set( 0.002, 0.002, 0.002 )
zAxis.add( zAxisLabel )





//  The cone that points to the surface of the sphere.

const blochPointer = new THREE.Mesh(

	new THREE.CylinderBufferGeometry( 0, 0.5, 1, 32, 1 ),
	new THREE.MeshPhongMaterial({ color: 0xFFDD44 })
)
blochPointer.geometry.translate( 0, -0.5, 0 )
blochPointer.geometry.rotateX( Math.PI / 2 )
blochPointer.geometry.scale( 0.2, 0.2, 0.2 )
blochPointer.lookAt( new THREE.Vector3() )
sphere.add( blochPointer )


//  The line from the sphere’s origin to its surface.

const blochVector = new THREE.Mesh(

	new THREE.BoxGeometry( 0.04, 0.04, 1 ),
	new THREE.MeshBasicMaterial({ color: 0xFFDD44 })
)
blochVector.geometry.translate( 0, 0, 0.5 )
sphere.add( blochVector )


//  x

const
radius = 1.005,
// arcR = radius * Math.sin( bloch.theta ),
// arcH = radius * Math.cos( bloch.theta ),
arcR = radius * Math.sin( Math.PI / 2 ),
arcH = radius * Math.cos( Math.PI / 2 ),
thetaGeometry = createLatitudeArc( arcR, 64, Math.PI / 2, Math.PI * 2 )

thetaGeometry.rotateX( Math.PI / 2 )
thetaGeometry.rotateY( Math.PI / 2 )
thetaGeometry.translate( 0, arcH, 0 )
const thetaRing = new THREE.Line( 

	thetaGeometry,
	new THREE.LineBasicMaterial({ color: 0x000000 })
)
sphere.add( thetaRing )


//  x

const
//arc = createLongitudeArc( radius, 64, Math.PI / -2, Math.PI ),
arc = createLongitudeArc( radius, 64, 0, Math.PI * 2 ),
phiGeometry = arc.clone()

// phiGeometry.rotateY( bloch.phi )
const phiArc = new THREE.Line( 

	phiGeometry,
	new THREE.LineBasicMaterial({ color: 0x000000 })
)
sphere.add( phiArc )








const controls = new THREE.OrbitControls( camera, renderer.domElement )
controls.enableZoom = false
controls.enablePan = false





function changeBlochVector(){


	//  Are we ready for a change?

	if( qubitCurrent !== qubitTarget ||
		gateCurrent  !== gateTarget ){


		//  Deselect all buttons -- except the one in use!

		Array.from( document.getElementById( 'bloch-sphere-qubits' ).children )
		.forEach( function( child ){

			if( child.getAttribute( 'data-qubit' ) === qubitTarget.name ){

				child.classList.add( 'selected' )
			}
			else child.classList.remove( 'selected' )
		})
		Array.from( document.getElementById( 'bloch-sphere-gates' ).children )
		.forEach( function( child ){

			if( child.getAttribute( 'data-gate' ) === gateTarget.name ){

				child.classList.add( 'selected' )
			}
			else child.classList.remove( 'selected' )
		})


		//  x

		if( qubitCurrent === undefined ) qubitCurrent = qubitTarget
		if( gateCurrent  === undefined ) gateCurrent  = gateTarget

		const 
		currentState = qubitCurrent.applyGate( gateCurrent ), 
		currentBloch = currentState.toBlochSphere()
		targetState  = qubitTarget.applyGate( gateTarget ),
		targetBloch  = targetState.toBlochSphere()


		//  Update our bra-ket readout.

		document.getElementById( 'bloch-bra' ).innerText = targetState.bra.toText( 4 )
		document.getElementById( 'bloch-ket' ).innerText = targetState.ket.toText( 4 )


		//  Tween our indicator to the target state.

		window.tween = new TWEEN.Tween({

				theta: currentBloch.theta,
				phi:   currentBloch.phi
			
			})//  Yes, this will be destructive to the blochState object.
			.to({

				theta: targetBloch.theta,
				phi:   targetBloch.phi
			
			}, 1000 )
			.easing( TWEEN.Easing.Quadratic.InOut )
			.onUpdate( updateBlochVector )
			.start()


		//  Make it ready to go for next time.

		qubitCurrent = qubitTarget
		gateCurrent  = gateTarget
	}
}








function updateBlochVector( input ){


	//  Move the big-ass surface pointer.

	blochPointer.position.set(
		
		Math.sin( input.theta ) * Math.sin( input.phi ),
		Math.cos( input.theta ),
		Math.sin( input.theta ) * Math.cos( input.phi )
	)
	blochPointer.lookAt( new THREE.Vector3() )


	blochVector.lookAt( blochPointer.getWorldPosition( new THREE.Vector3() ))


	//  Update our angles labels.
	
	document.getElementById( 'bloch-theta' ).innerText = ( input.theta * Q.RADIANS_TO_DEGREES ).toFixed()
	document.getElementById( 'bloch-phi' ).innerText = ( input.phi * Q.RADIANS_TO_DEGREES ).toFixed()


	const thetaSafe = Math.max( input.theta, 0.01 )
	thetaRing.scale.set(

		Math.sin( thetaSafe ),
		1,
		Math.sin( thetaSafe )
	)
	thetaRing.position.y = Math.cos( input.theta )


	
	//phiArc.rotateY( Math.PI - input.phi )
	phiArc.rotation.y = input.phi - Math.PI / 2




	/*
	const
	radius = 1,
	arcR = radius * Math.sin( bloch.theta ),
	arcH = radius * Math.cos( bloch.theta ),
	thetaGeometry = createLatitudeArc( arcR, 64, Math.PI / 2, Math.PI * 2 )

	thetaGeometry.rotateX( Math.PI / 2 )
	thetaGeometry.rotateY( Math.PI / 2 )
	thetaGeometry.translate( 0, arcH, 0 )
	sphere.add( new THREE.Line( 

		thetaGeometry,
		new THREE.LineBasicMaterial({ color: 0x000000 })
	))



	const
	arc = createLongitudeArc( radius, 64, Math.PI / -2, Math.PI )
	phiGeometry = arc.clone()
	
	phiGeometry.rotateY( bloch.phi )
	sphere.add( new THREE.Line( 

		phiGeometry,
		new THREE.LineBasicMaterial({ color: 0x000000 })
	))
	*/


	// blochVector.lookAt( blochCorrected )

	// mesh.position.copy( blochCorrected.clone().multiplyScalar( 10.1 + size / 2 ))

	//blochVectorLine.geometry.vertices[ 1 ].copy( blochCorrected.clone().multiplyScalar( 10.1 ))
	
	// const a = blochCorrected.clone()//.multiplyScalar( 10.1 )
	// blochVectorLine.geometry.setPositions([ 
	
	// 	0,  0, 0,  
	// 	a.x, a.y, a.z
	// ])
}











//  Create the qubit buttons.

let 
qubitTarget = Q.Qubit.HORIZONTAL,
qubitCurrent

const blochSphereQubits = document.getElementById( 'bloch-sphere-qubits' )
Object.keys( Q.Qubit.constants ).forEach( function( key ){

	const 
	qubit = Q.Qubit[ key ],
	qubitContainerElement = document.createElement( 'div' ),
	qubitElement = document.createElement( 'div' ),
	qubitNameElement = document.createElement( 'p' )
	
	qubitContainerElement.classList.add( 'bloch-sphere-qubit-container' )
	qubitContainerElement.setAttribute( 'data-qubit', qubit.name )
	qubitContainerElement.addEventListener( 'click', function(){

		qubitTarget = qubit
		changeBlochVector()
	})
	
	qubitElement.classList.add( 'bloch-sphere-qubit' )
	qubitElement.setAttribute( 'title', qubit.name )
	qubitElement.innerText = qubit.label
	qubitContainerElement.appendChild( qubitElement )

	qubitNameElement.innerText = qubit.name
	qubitContainerElement.appendChild( qubitNameElement )
	
	blochSphereQubits.appendChild( qubitContainerElement )
})




//  Create the gate buttons.

let 
gateTarget = Q.Gate.IDENTITY,
gateCurrent

const blochSphereGates = document.getElementById( 'bloch-sphere-gates' )
;[
	'IDENTITY',
	'HADAMARD',
	'PAULI_X',
	'PAULI_Y',
	'PAULI_Z',
	'PHASE',
	'PI_8'

].forEach( function( gateName ){

	const 
	gate = Q.Gate[ gateName ],
	gateContainerElement = document.createElement( 'div' ),
	gateElement = document.createElement( 'div' ),
	gateNameElement = document.createElement( 'p' )

	gateContainerElement.classList.add( 'bloch-sphere-gate-container' )
	gateContainerElement.setAttribute( 'data-gate',  gate.name )
	gateContainerElement.addEventListener( 'click', function(){

		gateTarget = gate
		changeBlochVector()
	})

	gateElement.classList.add( 'bloch-sphere-gate' )

	gateElement.setAttribute( 'title', gate.name )
	gateElement.innerText = gate.label
	gateContainerElement.appendChild( gateElement )

	gateNameElement.innerText = gate.name
	gateContainerElement.appendChild( gateNameElement )
	
	blochSphereGates.appendChild( gateContainerElement )
})











changeBlochVector()




sphere.rotation.x = 0.7
sphere.rotation.z = 0.2



const render = function(){

	requestAnimationFrame( render )
	controls.update()
	sphere.rotation.y += 0.0009;
	
	cameraWorldPosition = camera.getWorldPosition( new THREE.Vector3() )
	xAxisLabel.lookAt( cameraWorldPosition )
	yAxisLabel.lookAt( cameraWorldPosition )
	zAxisLabel.lookAt( cameraWorldPosition )

	renderer.render( scene, camera )
	TWEEN.update()
}

window.addEventListener( 'resize', function () {

	const
	width  = container.offsetWidth,
	height = container.offsetHeight
	
	camera.aspect = width / height
	camera.updateProjectionMatrix()
	renderer.setSize( width, height )

}, false )

render()







		</script>
	</body>
</html>