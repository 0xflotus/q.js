<!DOCTYPE html>
<html>
	<head>
		<title>Q ⟩ Qubit</title>
		<meta charset="utf-8">
		<meta name="description"          content="Q.js is quantum computing in your browser.">
		<meta name="copyright"            content="Stewart Smith 2019">
		<meta name="keywords"             content="
			Q, Q.js, Qjs,
			quantum, quantum physics, quantum mechanics, superposition,
			quantum computer, quantum computer programming, quantum computing, QC, 
			quantum simulator, quantum computer simulator, 
			qubit, qbit, gate, Hadamard, Bloch, Bloch Sphere,
			Web, Web site, website, Web browser, browser, HTML, HTML5, JavaScript, ES6, CSS,
			Chrome, Firefox, Safari, Opera, Brave, Edge, WebKit, Blink,
			Stewart Smith, Stewart, Stew, Stuart, Steven, Steve, Stewdio, stew_rtsmith, @stew_rtsmith,
			Moar, Moar Technologies Corp, MTC,
			Google, IBM, Microsoft, NASA, DWave, D-Wave,
			Quil, OpenQASM,
				ProjectQ, Qiskit, 
				Quantum Development Kit, Cirq, Strawberry Fields, t|ket>,
				QCL, Quantum pseudocode, Q#, Q|SI>, Q language, qGCL, QFC, QML, LIQUi|>, Quipper,
			Stanford CS 269 Q: Quantum Computer Programming">
		
		<meta name="twitter:card"         content="summary">
		<meta name="twitter:site"         content="@stew_rtsmith">
		<meta name="twitter:creator"      content="@stew_rtsmith">
		<meta name="twitter:title"        content="Q ⟩ Qubit">
		<meta name="twitter:description"  content="Quantum computing in your browser.">
		<meta name="twitter:image"        content="https://stewdio.github.io/q.js/Assets/q-thumbnail.png">
		
		<meta property="og:type"          content="website">
		<meta property="og:title"         content="Q ⟩ Qubit">
		<meta property="og:description"   content="Quantum computing in your browser.">
		<meta property="og:image"         content="https://stewdio.github.io/q.js/Assets/q-thumbnail.png">
		<meta property="og:url"           content="https://stewdio.github.io/q.js/Qubit.html">
		
		<link rel="canonical"             href="https://stewdio.github.io/q.js/Qubit.html">
		<link rel="icon" type="image/png" href="Assets/q-favicon-064.png">
		<link rel="apple-touch-icon"      href="Assets/q-favicon-144.png">
		<link rel="stylesheet" type="text/css" href="Assets/style.css">
		
		<script async src="https://www.googletagmanager.com/gtag/js"></script>
		<script src="Assets/ga.js"></script>
		<script src="Q/Q.js"></script>
		<script src="Q/ComplexNumber.js"></script>
		<script src="Q/Matrix.js"></script>
		<script src="Q/Qubit.js"></script>
		<script src="Q/Gate.js"></script>
		<script src="Q/Circuit.js"></script>
		<script src="Assets/navigation.js"></script>
		<script src="Assets/Three/three.105.min.js"></script>
		<script src="Assets/Three/OrbitControls.js"></script>
		<script src="Assets/Tween/tween.min.js"></script>
		<script src="Assets/blochSphere.js"></script>
		<script src="Assets/SurfaceText.js"></script>
	</head>
	<body>
		<main>
			<h3 id="Perfect_pairs">Perfect pairs</h3>
			<p>
				A <a href="https://en.wikipedia.org/wiki/Qubit" target="_blank">qubit</a>
				is a pair of <a href="ComplexNumber.html">complex numbers</a>, 
				<span class="symbol">a</span> and <span class="symbol">b</span>,
				such that |<span class="symbol">a</span>|<sup>2</sup> + |<span class="symbol">b</span>|<sup>2</sup> = 1. 
				That is to the say, 
				the absolute value of <span class="symbol">a</span> 
				multiplied by the absolute value of <span class="symbol">a</span>, 
				added to the absolute value of <span class="symbol">b</span> 
				multiplied by absolute value of <span class="symbol">b</span>,
				equals one.
			</p>
			<p>
				Qubits are represented by
				<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">bra-ket notation</a>. 
				Our <span class="symbol">a</span> argument represents our qubit’s “bra” 
				while our <span class="symbol">b</span> argument 
				represents our qubit’s “ket”—the part we are ultimately concerned with. 
				A qubit may be in 
				<a href="https://en.wikipedia.org/wiki/Quantum_superposition" target="_blank">superposition</a>, 
				ie. its target bit is neither 0 
				or 1, but somewhere in between.
				The probability that upon measurement the qubit bit will “collapse” to zero is 
				|<span class="symbol">a</span>|<sup>2</sup>, while the 
				probability that the qubit will collapse to one is 
				|<span class="symbol">b</span>|<sup>2</sup>. 
			</p>
			<br>
			<ul>
				<li>A qubit {<span class="symbol">a</span>=1, <span class="symbol">b</span>=0} has a 100% chance of collapsing to 0.</li>
				<li>A qubit {<span class="symbol">a</span>=0, <span class="symbol">b</span>=1} has a 100% chance of collapsing to 1.</li>
				<li>A qubit {<span class="symbol">a</span>=1÷√2, <span class="symbol">b</span>=1÷√2} has a 50% chance of collapsing to 0, and a 50% 
				chance of collapsing to 1.</li>
			</ul>
			<h3 id="Unit_circle">Unit circle</h3>
			<p>
				Given the constraints above, if we plot all of the possible <em>real</em> values for 
				<span class="symbol">a</span>, <span class="symbol">b</span> on a graph 
				as <span class="symbol">x</span> and <span class="symbol">y</span> respectively
				the outcome is a circle with a radius of 1 centered at the origin (0, 0); 
				ie. a <a href="https://en.wikipedia.org/wiki/Unit_circle)" target="_blank">unit circle</a>.
			</p>
			<div class="unit-circle">
				<div class="unit-circle-outline"></div>
				<div class="unit-circle-spoke unit-circle-spoke-0"></div>
				<div class="unit-circle-spoke unit-circle-spoke-45"></div>
				<div class="unit-circle-spoke unit-circle-spoke-90"></div>
				<div class="unit-circle-spoke unit-circle-spoke-135"></div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-90">Vertical</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-45">Diagonal</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-0">Horizontal</div>
				<div class="unit-circle-spoke-label unit-circle-spoke-label-315">Anti-diagonal</div>
				<div class="unit-circle-label unit-circle-label-angle-0">0˚</div>
				<div class="unit-circle-label unit-circle-label-angle-45">45˚</div>
				<div class="unit-circle-label unit-circle-label-angle-90">90˚</div>
				<div class="unit-circle-label unit-circle-label-angle-135">135˚</div>
				<div class="unit-circle-label unit-circle-label-angle-180">180˚</div>
				<div class="unit-circle-label unit-circle-label-angle-225">225˚</div>
				<div class="unit-circle-label unit-circle-label-angle-270">270˚</div>
				<div class="unit-circle-label unit-circle-label-angle-315">315˚</div>
				<div class="unit-circle-label unit-circle-label-point-0">1, 0</div>
				<div class="unit-circle-label unit-circle-label-point-45">
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-90">0, 1</div>
				<div class="unit-circle-label unit-circle-label-point-135">
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-180">-1, 0</div>
				<div class="unit-circle-label unit-circle-label-point-225">
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
				<div class="unit-circle-label unit-circle-label-point-270">0, -1</div>
				<div class="unit-circle-label unit-circle-label-point-315">
					<table class="division">
						<tr class="dividend"><td>1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>,
					<table class="division">
						<tr class="dividend"><td>-1</td></tr>
						<tr class="divisor"><td>√ 2</td></tr>
					</table>
				</div>
			</div>
			<h3 id="Bloch_sphere">Bloch sphere</h3>
			<p>
				But a qubit isn’t just a pair of <em>real</em> numbers—it’s a pair of <a href="ComplexNumber.html">complex numbers</a> and plotting those values requires a third dimension.
				This transforms our unit circle in to a
				<a href="https://en.wikipedia.org/wiki/Bloch_sphere" target="_blank">Bloch sphere</a>.
				<!--

				THIS IS A TERRIBLE AND INACCURATE EXPLANATION!
				MUST COME BACK AND RE-WRITE, FOCUS ON THE MATH!

				If you’re familiar with complex numbers you may expect them to add <em>two</em> dimensions to our unit circle rather than one.
				By taking the absolute value of <span class="symbol">a</span> or <span class="symbol">b</span>
				we effectively cancel out this extra dimension.
				-->

				Our unit circle or Bloch Sphere could be used as a state 
				machine for quantum compuation, though 
				<a href="Q.html">Q</a> currently focusses on 
				matrices for calculation. 
			</p>
			<br>
			<p>
				Select a qubit state:
			</p>
			<div id="bloch-sphere-qubits"></div>
			<p>
				Select a gate to apply:
			</p>
			<div id="bloch-sphere-gates"></div>
			<div class="interactive-container" id="bloch-sphere">
				<div class="interactive-component" id="bloch-angles">
					<span class="symbol">a</span> = <span id="bloch-bra">—</span><br>
					<span class="symbol">b</span> = <span id="bloch-ket">—</span><br>
					<br>
					<span id="bloch-theta">—</span>˚ polar angle θ (theta)<br>
					<span id="bloch-phi">—</span>˚ azimuth angle ϕ (phi)
				</div>
			</div>
			<p>
				Click and drag the Bloch Sphere to rotate it.
			</p>
			<hr>
			<h3 id="Constructor">Constructor</h3>
			<p>
				<code>Qubit</code>
				extends the <code><a href="Matrix.html">Matrix</a></code> class
				and therefore inherits its static and prototypal properties.
				The constructor expects two arguments that are each either
				instances of <code>Number</code> or <code><a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a></code>.
				An optional third argument, expected in the form of a single character <code>String</code>, may be used as a text label for the qubit.
				If no text label is provided the constructor checks against the list of existing 
				<code><a href="#.constants">constants</a></code>
				and if a match is found then that label is applied to this instance.
			</p>
			<p>
				When a new qubit is created it internally invokes the
				<code><a href="Q.html">Q</a>.<a href="Matrix.html">Matrix</a></code> constructor,
				such that <code>new <a href="Q.html">Q</a>.Qubit( <span class="symbol">a</span>, <span class="symbol">b</span> )</code>
				is similar to
				<code>new <a href="Q.html">Q</a>.<a href="Matrix.html">Matrix</a>([ <span class="symbol">a</span> ],[ <span class="symbol">b</span> ])</code>.
				If the two supplied values do not satisfy the assertion that
				|<span class="symbol">a</span>|<sup>2</sup> + |<span class="symbol">b</span>|<sup>2</sup> = 1 
				then an error is thrown.
			</p>
<pre><code>
var a = new <a href="Q.html">Q</a>.Qubit( 0, 1 )
</code></pre>
			<ul class="properties">
				<li>
					<dt id="this.bra">bra</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a></code>
						The <span class="symbol">a</span> or 
						<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">bra</a> component of the qubit state.
					</dd>
				</li>
				<li>
					<dt id="this.ket">ket</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a></code>
						The <span class="symbol">b</span> or 
						<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation" target="_blank">ket</a> component of the qubit state.
					</dd>
				</li>
				<li>
					<dt id="this.label">label</dt>
					<dd>
						<code class="value-type">String</code>
						Single character representing this qubit state, 
						for example ‘H’ for <a href="#.HORIZONTAL">horizontal</a>. 
						This can be passed to the constructor as an optional third argument 
						or automatically assigned based on existing <code><a href="Q.html">Q</a>.Qubit.<a href="#.constants">constants</a></code>
						If no match is found among existings constants the ‘?’ character is assigned.
						Note: This property name and behavior expected to change in the near future.
					</dd>
				</li>
				<li>
					<dt id="this.name">name</dt>
					<dd>
						<code class="value-type">String</code>
						The name of the qubit state, assigned based on existing <code>Q.Qubit.<a href="#.constants">constants</a></code>.
						If no match is found among existings constants the name is left empty.
						Note: This property name and behavior expected to change in the near future.
					</dd>
				</li>
				<li>
					<dt id="this.index">index</dt>
					<dd>
						<code class="value-type">Number</code>
						An identification number assigned to the instance based on the
						auto-incrementing static number <code><a href="Q.html">Q</a>.Qubit.<a href="#.index">index</a></code>.
						Used for minding the total number of instances created.
					</dd>
				</li>
			</ul>
			<h3 id="Static_constants">Static constants</h3>
			<p>
				While <code><a href="Q.html">Q</a>.Qubit</code> constants
				are appended directly to the 
				<code><a href="Q.html">Q</a>.Qubit</code> object,
				they are also appended to a 
				<code><a href="Q.html">Q</a>.Qubit.<a href="#.constants">constants</a></code> object
				to make looking up constants in the JavaScript console trivial,
				and to make iterating across all constants convenient via
				functions like 
				<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">Object.entries</a></code>,
				<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">Object.keys</a></code>,
				<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">Object.values</a></code>,
				and so on.
				Strictly speaking, all constants are merely properties—but 
				these particular properties are configured to be unwritable once appended via
				<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">Object.defineProperty</a></code>
				and are labeled in uppercase to signal to us that this is so.
			</p>
			<p>
				<code><a href="Q.html">Q</a>.Qubit</code> provides the following built-in <a href="https://en.wikipedia.org/wiki/Jones_calculus#Jones_vectors" target="_blank">Jones vectors</a>.
			</p>
			<ul class="properties">
				<li>
					<dt id=".HORIZONTAL">HORIZONTAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( 1, 0, 'H', 'Horizontal' )</code>.
						Commonly thought of as “zero” or “off.”
						Described by the following matrix:<br>
						<div class="matrix qubit">
							<div class="matrix-bracket-left"></div>
							<div class="matrix-bracket-right"></div>
							<table>
								<tr><td>1</td></tr>
								<tr><td>0</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".VERTICAL">VERTICAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( 0, 1, 'V', 'Vertical' )</code>.
						Commonly thought of as “one” or “on.”
						Described by the following matrix:<br>
						<div class="matrix qubit">
							<div class="matrix-bracket-left"></div>
							<div class="matrix-bracket-right"></div>
							<table>
								<tr><td>0</td></tr>
								<tr><td>1</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".DIAGONAL">DIAGONAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, Math.SQRT1_2, 'D', 'Diagonal' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>1</td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".ANTI_DIAGONAL">ANTI_DIAGONAL</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, -Math.SQRT1_2, 'A', 'Anti-diagonal' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>-1</td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".RIGHT_HAND_CIRCULAR_POLARIZED">RIGHT_HAND_CIRCULAR_POLARIZED</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, new <a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a>( 0, -Math.SQRT1_2 ), 'R', 'Right-hand Circular Polarized' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td>-<span class="symbol">i</span></td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
				<li>
					<dt id=".LEFT_HAND_CIRCULAR_POLARIZED">LEFT_HAND_CIRCULAR_POLARIZED</dt>
					<dd>
						<code class="value-type"><a href="Q.html">Q</a>.Qubit</code>
						Initialized as
						<code>new <a href="Q.html">Q</a>.Qubit( Math.SQRT1_2, new <a href="Q.html">Q</a>.<a href="ComplexNumber.html">ComplexNumber</a>( 0, Math.SQRT1_2 ), 'L', 'Left-hand Circular Polarized' )</code>.
						Described by the following matrix:<br>
						<div class="maths">
							<div class="matrix qubit">
								<div class="matrix-bracket-left"></div>
								<div class="matrix-bracket-right"></div>
								<table>
									<tr><td>1</td></tr>
									<tr><td><span class="symbol">i</span></td></tr>
								</table>
							</div>
							×
							<table class="division">
								<tr class="dividend"><td>1</td></tr>
								<tr class="divisor"><td>√ 2</td></tr>
							</table>
						</div>
					</dd>
				</li>
			</ul>
			<h3 id="Static_properties">Static properties</h3>
			<p>
				Because <code>Q.Qubit</code> extends <code>Q.<a href="Matrix.html">Matrix</a></code>,
				the following append or replace the latter’s existing static properties.
			</p>
			<ul class="properties">
				<li>
					<dt id=".index">index</dt>
					<dd>
						<code class="value-type">Number</code>
						Initialized to zero, this number is then incremented each time an instance is created
						in order to promote mindfulness of the total number instances in the system.
						At the time of instance creation the instance is assigned a copy of this value
						to its own <code><a href="#this.index">index</a></code> property.
					</dd>
				</li>
				<li>
					<dt id=".help">help</dt>
					<dd>
						<code class="value-type">Function</code>
						Calls and returns the result of <code>Q.<a href="Q.html#.help">help</a>( this )</code>
						to provide helpful context in the form of a <code>String</code>.
						Expects no arguments.
					</dd>
				</li>
				<li>
					<dt id=".constants">constants</dt>
					<dd>
						<code class="value-type">Object</code>
						While <code>Q.Qubit</code> <a href="#.constants">constants</a>
						are appended directly to the <code>Q.Qubit</code> object,
						they are also appended to a <code>Q.Qubit.constants</code> object
						to make looking up constants in the JavaScript console trivial,
						and to make iterating across all constants convenient via
						functions like 
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">Object.entries</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">Object.keys</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">Object.values</a></code>,
						and so on.
					</dd>
				</li>
				<li>
					<dt id=".createConstant">createConstant</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects <code>( key, value )</code> as arguments.
						Assigns a reference to <code>value</code> to <code>Q.Qubit[ key ]</code>
						as well as <code>Q.Qubit.<a href="#.constants">constants</a>[ key ]</code>.
						The former is for coding convenience (short form) while the latter
						makes iterating across all constants convenient via
						functions like 
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank">Object.entries</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">Object.keys</a></code>,
						<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">Object.values</a></code>,
						and so on.
					</dd>
				</li>
				<li>
					<dt id=".createConstants">createConstants</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects an even number of arguments in the form of
						<code>( key, value, key, value, key, value … )</code>
						and with each <code>key</code> / <code>value</code> pair calls 
						<code><a href="#.createConstant">createConstant</a></code>.
					</dd>
				</li>
				<li>
					<dt id=".collapse">collapse</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects a single <code>Q.Qubit</code> instance as argument.
						Returns a new <code>Q.Qubit</code> randomly chosen to be either
						<code>new Qubit( 1, 0 )</code> (<code><a href="#.HORIZONTAL">HORIZONTAL</a></code>)
						 or
						 <code>new Qubit( 0, 1 )</code> (<code><a href="#.VERTICAL">VERTICAL</a></code>)
						 based on the probability of the supplied qubit argument.
					</dd>
				</li>
				<li>
					<dt id=".areEqual">areEqual</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects two instances of <code>Q.Qubit</code> as arguments.
						If the <code><a href="#.bra">bra</a></code> of each are within 
						<code>Q.<a href="Q.html#.EPSILON">EPSILON</a></code>
						and the <code><a href="#.ket">ket</code></a> of each are within 
						<code>Q.<a href="Q.html#.EPSILON">EPSILON</a></code>
						then returns <code>true</code>, otherwise <code>false</code>.
					</dd>
				</li>
				<li>
					<dt id=".toBlochSphere">toBlochSphere</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects a single <code>Q.Qubit</code> instance as argument.
						Returns the following object for a given qubit’s probability state,
						useful for rendering a <a href="#Bloch_sphere">Bloch Sphere</a> representation.
<pre><code>
{
	theta, <span class="comment">//  Polar angle θ.</span>
	phi,   <span class="comment">//  Azimuth angle ϕ.</span>

	
	<span class="comment">//  Bloch vector,
	//  the surface point on a Bloch Sphere.</span>

	vector: { x, y, z },

	
	<span class="comment">//  Bloch vector “corrected”
	//  for Y-up coordinate systems.</span>

	position: {

		x: vector.<strong>y</strong>,<span class="comment">//  Note this Y here.</span>
		y: vector.<strong>z</strong>,<span class="comment">//  Note this Z here.</span>
		z: vector.<strong>x</strong> <span class="comment">//  Note this X here.</span>
	}
}
</code></pre>					
					</dd>
				</li>


				<!--

					toBlochSphere
					toXYZ
					fromBlochSphere
					fromXYZ

				-->
			</ul>
			<h3 id="Prototype_properties">Prototype properties</h3>
			<p>
				Because <code>Q.Qubit</code> extends <code>Q.<a href="Matrix.html">Matrix</a></code>,
				the following append or replace the latter’s existing prototype properties.
			</p>
			<h4>Non-destructive methods</h4>
			<ul class="properties">
				<li>
					<dt id=".prototype.isEqualTo">isEqualTo</dt>
					<dd>
						<code class="value-type">Function</code>
						Calls and returns the result of static method 
						<code>Q.Qubit.<a href="#.areEqual">areEqual</a>( this, otherQubit )</code>.
						The returned <code>Boolean</code> breaks method chaining.
					</dd>
				</li>
				<li>
					<dt id=".prototype.collapse">collapse</dt>
					<dd>
						<code class="value-type">Function</code>
						Calls and returns the result of static method 
						<code>Q.Qubit.<a href="#.collapse">collapse</a>( this )</code>.
					</dd>
				</li>
				<li>
					<dt id=".prototype.toBlochSphere">toBlochSphere</dt>
					<dd>
						<code class="value-type">Function</code>
						Calls and returns the result of static method 
						<code>Q.Qubit.<a href="#.toBlochSphere">toBlochSphere</a>( this )</code>.
						The returned <code>Object</code> breaks method chaining.
					</dd>
				</li>
			</ul>
			<h4>Destructive methods</h4>
			<ul class="properties">
				<li>
					<dt id=".prototype.copy$">copy$</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects a single <code>Q.Qubit</code> instance as argument.
						Overwrites the internal <code>bra</code>
						and <code>ket</code> values
						with those of the supplied <code>Q.Qubit</code> instance argument.
					</dd>
				</li>
				<li>
					<dt id=".prototype.collapse$">collapse$</dt>
					<dd>
						<code class="value-type">Function</code>
						Expects no arguments.
						Calls the non-destructive <code><a href="#.prototype.collapse">collapse</a></code> method,
						then uses <code><a href="#.prototype.copy$">copy$</a></code> to overwrite
						this qubit’s values.
					</dd>
				</li>
			</ul>
			<hr>
			<footer>
				<p>
					Source:
					<a href="https://github.com/stewdio/q.js/blob/master/Q/Qubit.js?ts=4" target="_blank">https://github.com/stewdio/q.js/blob/master/Q/Qubit.js</a>
				</p>
			</footer>
		</main>
		<script>


//  First, what do the docs have to say?

// console.log( '\n\nQ.Qubit\n\n', Q.Qubit.help(), '\n\n' )





/*

	O M F G

	Please forgive the below hideous code
	and interaction that goes with it.
	And the explainer text above that goes with it.
	This is SUCH A WORK IN PROGRESS RIGHT NOW!
	Coming back to fix shortly.

*/




//  First, what do the docs have to say?

//console.log( '\n\nQ.Qubit\n', Q.Qubit.help(), '\n\n' )













//  Create our Bloch Sphere explorer.

const
container = document.getElementById( 'bloch-sphere' ),
fov    = 45,
width  =  container.offsetWidth,
height =  container.offsetHeight,
aspect =  width / height,
near   = 0.1,
far    = 12,
scene  = new THREE.Scene(),
camera = new THREE.PerspectiveCamera( fov, aspect, near, far ),
renderer = new THREE.WebGLRenderer({ 

	// canvas: container,
	alpha: true,
	antialias: true
})

container.appendChild( renderer.domElement )
camera.position.z = 4
renderer.setPixelRatio( window.devicePixelRatio )
renderer.setSize( width, height )
scene.add( camera )


//  We’re going to pull a little trick here...
//  Let’s put our light in the opposite place of where we want it
//  because we’ll render the back face of the sphere
//  so light direction will be inverted.
//  We’ll also attach it to the camera
//  so the light doesn’t appear to move.


const light = new THREE.PointLight( 0xFFFFFF, 0.5, 0 )
light.position.set( -2, 6, 0 )
camera.add( light )
scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.8 ))


//  x

const sphere = new THREE.Group()
scene.add( sphere )


//  Create lines of latitude and longitude.

const grid = createQuadSphere({ radius: 1 })
sphere.add( grid )


//  x

const innards = new THREE.Mesh( 

	new THREE.SphereGeometry( 0.995, 32, 32 ),
	new THREE.MeshPhongMaterial({

		side: THREE.FrontSide,
		color: 0xE6E6E6,
		transparent: true,
		opacity: 0.8
	}) 
)
sphere.add( innards )




const yAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 2.5, 0.01, 0.01 ),
	new THREE.MeshBasicMaterial({ color: 0x33BB77 })
)
sphere.add( yAxis )

const xAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 0.01, 0.01, 2.5 ),
	new THREE.MeshBasicMaterial({ color: 0xFF4433 })
)
sphere.add( xAxis )

const zAxis = new THREE.Mesh(

	new THREE.BoxGeometry( 0.01, 2.5, 0.01 ),
	new THREE.MeshBasicMaterial({ color: 0x0366D6 })
)
sphere.add( zAxis )





const 
arrowLength     = 0.101,//  I know, weird, right?
arrowHeadLength = 0.1,
arrowHeadWidth  = 0.1

sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 0, 1.0, 0 ), 
	new THREE.Vector3( 0, 1.25, 0 ), 
	arrowLength, 
	0x0366D6, 
	arrowHeadLength, 
	arrowHeadWidth
))
sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 1.0, 0, 0 ), 
	new THREE.Vector3( 1.25, 0, 0 ), 
	arrowLength, 
	0x33BB77, 
	arrowHeadLength, 
	arrowHeadWidth
))
sphere.add( new THREE.ArrowHelper( 

	new THREE.Vector3( 0, 0, 1.0 ), 
	new THREE.Vector3( 0, 0, 1.25 ),
	arrowLength, 
	0xFF4433, 
	arrowHeadLength, 
	arrowHeadWidth
))





const axesLabelStyle = {

	width:   128,
	height:  128,
	fillStyle: '#000',
	font: 'bold italic 64px Georgia, "Times New Roman", serif'
}
const xAxisLabel = new SurfaceText( axesLabelStyle )
xAxisLabel.print( 'x' )
xAxisLabel.position.set( 0, 0, 1.45 )
xAxisLabel.scale.set( 0.002, 0.002, 0.002 )
xAxis.add( xAxisLabel )

const yAxisLabel = new SurfaceText( axesLabelStyle )
yAxisLabel.print( 'y' )
yAxisLabel.position.set( 1.45, 0, 0 )
yAxisLabel.scale.set( 0.002, 0.002, 0.002 )
yAxis.add( yAxisLabel )


const zAxisLabel = new SurfaceText( axesLabelStyle )
zAxisLabel.print( 'z' )
zAxisLabel.position.set( 0, 1.45, 0 )
zAxisLabel.scale.set( 0.002, 0.002, 0.002 )
zAxis.add( zAxisLabel )





//  The cone that points to the surface of the sphere.

const blochPointer = new THREE.Mesh(

	new THREE.CylinderBufferGeometry( 0, 0.5, 1, 32, 1 ),
	new THREE.MeshPhongMaterial({ color: 0xFFDD44 })
)
blochPointer.geometry.translate( 0, -0.5, 0 )
blochPointer.geometry.rotateX( Math.PI / 2 )
blochPointer.geometry.scale( 0.2, 0.2, 0.2 )
blochPointer.lookAt( new THREE.Vector3() )
sphere.add( blochPointer )


//  The line from the sphere’s origin to its surface.

const blochVector = new THREE.Mesh(

	new THREE.BoxGeometry( 0.04, 0.04, 1 ),
	new THREE.MeshBasicMaterial({ color: 0xFFDD44 })
)
blochVector.geometry.translate( 0, 0, 0.5 )
sphere.add( blochVector )


//  x

const
radius = 1.005,
// arcR = radius * Math.sin( bloch.theta ),
// arcH = radius * Math.cos( bloch.theta ),
arcR = radius * Math.sin( Math.PI / 2 ),
arcH = radius * Math.cos( Math.PI / 2 ),
thetaGeometry = createLatitudeArc( arcR, 64, Math.PI / 2, Math.PI * 2 )

thetaGeometry.rotateX( Math.PI / 2 )
thetaGeometry.rotateY( Math.PI / 2 )
thetaGeometry.translate( 0, arcH, 0 )
const thetaRing = new THREE.Line( 

	thetaGeometry,
	new THREE.LineBasicMaterial({ color: 0x000000 })
)
sphere.add( thetaRing )


//  x

const
//arc = createLongitudeArc( radius, 64, Math.PI / -2, Math.PI ),
arc = createLongitudeArc( radius, 64, 0, Math.PI * 2 ),
phiGeometry = arc.clone()

// phiGeometry.rotateY( bloch.phi )
const phiArc = new THREE.Line( 

	phiGeometry,
	new THREE.LineBasicMaterial({ color: 0x000000 })
)
sphere.add( phiArc )








const controls = new THREE.OrbitControls( camera, renderer.domElement )
controls.enableZoom = false
controls.enablePan = false





function changeBlochVector(){


	//  Are we ready for a change?

	if( qubitCurrent !== qubitTarget ||
		gateCurrent  !== gateTarget ){


		//  Deselect all buttons -- except the one in use!

		Array.from( document.getElementById( 'bloch-sphere-qubits' ).children )
		.forEach( function( child ){

			if( child.getAttribute( 'data-qubit' ) === qubitTarget.name ){

				child.classList.add( 'selected' )
			}
			else child.classList.remove( 'selected' )
		})
		Array.from( document.getElementById( 'bloch-sphere-gates' ).children )
		.forEach( function( child ){

			if( child.getAttribute( 'data-gate' ) === gateTarget.name ){

				child.classList.add( 'selected' )
			}
			else child.classList.remove( 'selected' )
		})


		//  x

		if( qubitCurrent === undefined ) qubitCurrent = qubitTarget
		if( gateCurrent  === undefined ) gateCurrent  = gateTarget

		const 
		currentState = qubitCurrent.applyGate( gateCurrent ), 
		currentBloch = currentState.toBlochSphere()
		targetState  = qubitTarget.applyGate( gateTarget ),
		targetBloch  = targetState.toBlochSphere()


		//  Update our bra-ket readout.

		document.getElementById( 'bloch-bra' ).innerText = targetState.bra.toText( 4 )
		document.getElementById( 'bloch-ket' ).innerText = targetState.ket.toText( 4 )


		//  Tween our indicator to the target state.

		window.tween = new TWEEN.Tween({

				theta: currentBloch.theta,
				phi:   currentBloch.phi
			
			})//  Yes, this will be destructive to the blochState object.
			.to({

				theta: targetBloch.theta,
				phi:   targetBloch.phi
			
			}, 1000 )
			.easing( TWEEN.Easing.Quadratic.InOut )
			.onUpdate( updateBlochVector )
			.start()


		//  Make it ready to go for next time.

		qubitCurrent = qubitTarget
		gateCurrent  = gateTarget
	}
}








function updateBlochVector( input ){


	//  Move the big-ass surface pointer.

	blochPointer.position.set(
		
		Math.sin( input.theta ) * Math.sin( input.phi ),
		Math.cos( input.theta ),
		Math.sin( input.theta ) * Math.cos( input.phi )
	)
	blochPointer.lookAt( new THREE.Vector3() )


	blochVector.lookAt( blochPointer.getWorldPosition( new THREE.Vector3() ))


	//  Update our angles labels.
	
	document.getElementById( 'bloch-theta' ).innerText = ( input.theta * Q.RADIANS_TO_DEGREES ).toFixed()
	document.getElementById( 'bloch-phi' ).innerText = ( input.phi * Q.RADIANS_TO_DEGREES ).toFixed()


	const thetaSafe = Math.max( input.theta, 0.01 )
	thetaRing.scale.set(

		Math.sin( thetaSafe ),
		1,
		Math.sin( thetaSafe )
	)
	thetaRing.position.y = Math.cos( input.theta )


	
	//phiArc.rotateY( Math.PI - input.phi )
	phiArc.rotation.y = input.phi - Math.PI / 2




	/*
	const
	radius = 1,
	arcR = radius * Math.sin( bloch.theta ),
	arcH = radius * Math.cos( bloch.theta ),
	thetaGeometry = createLatitudeArc( arcR, 64, Math.PI / 2, Math.PI * 2 )

	thetaGeometry.rotateX( Math.PI / 2 )
	thetaGeometry.rotateY( Math.PI / 2 )
	thetaGeometry.translate( 0, arcH, 0 )
	sphere.add( new THREE.Line( 

		thetaGeometry,
		new THREE.LineBasicMaterial({ color: 0x000000 })
	))



	const
	arc = createLongitudeArc( radius, 64, Math.PI / -2, Math.PI )
	phiGeometry = arc.clone()
	
	phiGeometry.rotateY( bloch.phi )
	sphere.add( new THREE.Line( 

		phiGeometry,
		new THREE.LineBasicMaterial({ color: 0x000000 })
	))
	*/


	// blochVector.lookAt( blochCorrected )

	// mesh.position.copy( blochCorrected.clone().multiplyScalar( 10.1 + size / 2 ))

	//blochVectorLine.geometry.vertices[ 1 ].copy( blochCorrected.clone().multiplyScalar( 10.1 ))
	
	// const a = blochCorrected.clone()//.multiplyScalar( 10.1 )
	// blochVectorLine.geometry.setPositions([ 
	
	// 	0,  0, 0,  
	// 	a.x, a.y, a.z
	// ])
}











//  Create the qubit buttons.

let 
qubitTarget = Q.Qubit.HORIZONTAL,
qubitCurrent

const blochSphereQubits = document.getElementById( 'bloch-sphere-qubits' )
Object.keys( Q.Qubit.constants ).forEach( function( key ){

	const 
	qubit = Q.Qubit[ key ],
	qubitContainerElement = document.createElement( 'div' ),
	qubitElement = document.createElement( 'div' ),
	qubitNameElement = document.createElement( 'p' )
	
	qubitContainerElement.classList.add( 'bloch-sphere-qubit-container' )
	qubitContainerElement.setAttribute( 'data-qubit', qubit.name )
	qubitContainerElement.addEventListener( 'click', function(){

		qubitTarget = qubit
		changeBlochVector()
	})
	
	qubitElement.classList.add( 'bloch-sphere-qubit' )
	qubitElement.setAttribute( 'title', qubit.name )
	qubitElement.innerText = qubit.label
	qubitContainerElement.appendChild( qubitElement )

	qubitNameElement.innerText = qubit.name
	qubitContainerElement.appendChild( qubitNameElement )
	
	blochSphereQubits.appendChild( qubitContainerElement )
})




//  Create the gate buttons.

let 
gateTarget = Q.Gate.IDENTITY,
gateCurrent

const blochSphereGates = document.getElementById( 'bloch-sphere-gates' )
;[
	'IDENTITY',
	'HADAMARD',
	'PAULI_X',
	'PAULI_Y',
	'PAULI_Z',
	'PHASE',
	'PI_8'

].forEach( function( gateName ){

	const 
	gate = Q.Gate[ gateName ],
	gateContainerElement = document.createElement( 'div' ),
	gateElement = document.createElement( 'div' ),
	gateNameElement = document.createElement( 'p' )

	gateContainerElement.classList.add( 'bloch-sphere-gate-container' )
	gateContainerElement.setAttribute( 'data-gate',  gate.name )
	gateContainerElement.addEventListener( 'click', function(){

		gateTarget = gate
		changeBlochVector()
	})

	gateElement.classList.add( 'bloch-sphere-gate' )

	gateElement.setAttribute( 'title', gate.name )
	gateElement.innerText = gate.label
	gateContainerElement.appendChild( gateElement )

	gateNameElement.innerText = gate.name
	gateContainerElement.appendChild( gateNameElement )
	
	blochSphereGates.appendChild( gateContainerElement )
})











changeBlochVector()




sphere.rotation.x = 0.7
sphere.rotation.z = 0.2



const render = function(){

	requestAnimationFrame( render )
	controls.update()
	sphere.rotation.y += 0.0009;
	
	cameraWorldPosition = camera.getWorldPosition( new THREE.Vector3() )
	xAxisLabel.lookAt( cameraWorldPosition )
	yAxisLabel.lookAt( cameraWorldPosition )
	zAxisLabel.lookAt( cameraWorldPosition )

	renderer.render( scene, camera )
	TWEEN.update()
}

window.addEventListener( 'resize', function () {

	const
	width  = container.offsetWidth,
	height = container.offsetHeight
	
	camera.aspect = width / height
	camera.updateProjectionMatrix()
	renderer.setSize( width, height )

}, false )

render()







		</script>
	</body>
</html>